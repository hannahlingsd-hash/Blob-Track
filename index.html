<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Forking Sun — Ghost Paths (Point-Cloud)</title>
<style>
  :root{--bg:#0a0a0c;--fg:#d8e6ff;--acc:#7dd3fc;--mut:#7f8ea3}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font:14px/1.35 system-ui,Segoe UI,Roboto,Helvetica,Arial}
  .wrap{display:grid;grid-template-columns:320px 1fr;gap:14px;height:100%}
  aside{padding:14px 12px 16px;border-right:1px solid #1a1f2a;overflow:auto}
  main{position:relative}
  canvas,video{position:absolute;inset:0;width:100%;height:100%;object-fit:contain;background:#000}
  video{opacity:.15}
  .layers{position:absolute;inset:0}
  .row{display:flex;align-items:center;gap:8px;margin:9px 0}
  .row label{flex:1;color:var(--mut)}
  .row input[type="range"]{flex:2}
  h1{font-size:16px;margin:0 0 10px}
  fieldset{border:1px solid #1c2533;border-radius:10px;margin:10px 0;padding:10px}
  legend{padding:0 6px;color:#9fb4d4}
  .kbd{font:12px/1.2 ui-monospace,Menlo,Consolas;background:#121520;border:1px solid #1f2734;border-radius:6px;padding:1px 6px;color:#b8c7e8}
  .mut{color:#8191aa}
  .small{font-size:12px}
  .btn{appearance:none;border:1px solid #2a3650;background:#121725;color:#cfe3ff;border-radius:8px;padding:6px 10px;cursor:pointer}
  .btn:active{transform:translateY(1px)}
  a{color:#a7e0ff}
</style>
</head>
<body>
<div class="wrap">
  <aside>
    <h1>Forking Sun — Ghost Paths</h1>
    <div class="row">
      <input id="file" type="file" accept="video/*">
      <button id="play" class="btn">Play/Pause</button>
    </div>
    <div class="row small mut">
      Or URL param: <span class="kbd">?src=your.mp4</span>
    </div>

    <fieldset>
      <legend>Detection</legend>
      <div class="row"><label>Brightness threshold</label><input id="thr" type="range" min="0" max="255" value="220"><span id="thrV">220</span></div>
      <div class="row"><label>Blur (px)</label><input id="blur" type="range" min="0" max="6" value="2"><span id="blurV">2</span></div>
      <div class="row"><label>Mask % (top bright)</label><input id="pct" type="range" min="0.01" max="2" step="0.01" value="0.30"><span id="pctV">0.30%</span></div>
    </fieldset>

    <fieldset>
      <legend>Point-Cloud</legend>
      <div class="row"><label>Point size</label><input id="pt" type="range" min="1" max="6" value="2"><span id="ptV">2</span></div>
      <div class="row"><label>Cloud opacity</label><input id="palpha" type="range" min="0" max="1" step="0.01" value="0.55"><span id="palphaV">0.55</span></div>
      <div class="row"><label>Sample step (px)</label><input id="step" type="range" min="1" max="6" value="2"><span id="stepV">2</span></div>
    </fieldset>

    <fieldset>
      <legend>Trails (Past)</legend>
      <div class="row"><label>Trail decay</label><input id="decay" type="range" min="0.80" max="0.995" step="0.001" value="0.96"><span id="decayV">0.96</span></div>
      <div class="row"><label>Trail weight</label><input id="tw" type="range" min="0.5" max="4" step="0.1" value="2"><span id="twV">2</span></div>
    </fieldset>

    <fieldset>
      <legend>Ghosts (Future)</legend>
      <div class="row"><label># Branches</label><input id="k" type="range" min="0" max="8" value="4"><span id="kV">4</span></div>
      <div class="row"><label>Horizon (px)</label><input id="h" type="range" min="10" max="300" value="120"><span id="hV">120</span></div>
      <div class="row"><label>Angle jitter (°)</label><input id="jit" type="range" min="0" max="45" value="18"><span id="jitV">18</span></div>
      <div class="row"><label>Magnitude jitter</label><input id="mag" type="range" min="0" max="1" step="0.01" value="0.25"><span id="magV">0.25</span></div>
      <div class="row"><label>Ghost opacity</label><input id="galpha" type="range" min="0" max="1" step="0.01" value="0.28"><span id="galphaV">0.28</span></div>
      <div class="row"><label>Keep failed ghosts</label><input id="keep" type="checkbox" checked></div>
    </fieldset>

    <fieldset>
      <legend>Render</legend>
      <div class="row"><label>Dim video</label><input id="dim" type="range" min="0" max="1" step="0.01" value="0.85"><span id="dimV">0.85</span></div>
      <div class="row"><label>Sun dot size</label><input id="sd" type="range" min="2" max="10" value="5"><span id="sdV">5</span></div>
      <div class="row"><button id="snap" class="btn">Save Frame (PNG)</button><span class="small mut">photos folder in browser downloads</span></div>
    </fieldset>

    <div class="small mut">Tip: set threshold low for clouds/grass; high for direct sun. “Mask %” limits how many brightest pixels are used for centroid.</div>
  </aside>

  <main>
    <video id="vid" playsinline muted loop></video>
    <div class="layers">
      <canvas id="cloud"></canvas>   <!-- point cloud layer -->
      <canvas id="trails"></canvas>  <!-- decaying past + kept ghosts -->
      <canvas id="ghosts"></canvas>  <!-- live future branches -->
      <canvas id="hud"></canvas>     <!-- sun dot / UI -->
    </div>
  </main>
</div>

<script>
(function(){
  // DOM
  const vid = document.getElementById('vid');
  const file = document.getElementById('file');
  const playBtn = document.getElementById('play');
  const cs = {
    cloud: document.getElementById('cloud'),
    trails: document.getElementById('trails'),
    ghosts: document.getElementById('ghosts'),
    hud: document.getElementById('hud')
  };
  const ctx = Object.fromEntries(Object.entries(cs).map(([k,c])=>[k,c.getContext('2d')]));

  // Controls
  const ids = ["thr","blur","pct","pt","palpha","step","decay","tw","k","h","jit","mag","galpha","dim","sd"];
  const el = Object.fromEntries(ids.map(id=>[id, document.getElementById(id)]));
  const out = Object.fromEntries(ids.map(id=>[id+"V", document.getElementById(id+"V")]));
  const keepChk = document.getElementById('keep');
  const snapBtn = document.getElementById('snap');

  function syncLabels(){
    out.thrV.textContent = el.thr.value;
    out.blurV.textContent = el.blur.value;
    out.pctV.textContent = (+el.pct.value).toFixed(2) + "%";
    out.ptV.textContent = el.pt.value;
    out.palphaV.textContent = el.palpha.value;
    out.stepV.textContent = el.step.value;
    out.decayV.textContent = el.decay.value;
    out.twV.textContent = el.tw.value;
    out.kV.textContent = el.k.value;
    out.hV.textContent = el.h.value;
    out.jitV.textContent = el.jit.value;
    out.magV.textContent = el.mag.value;
    out.galphaV.textContent = el.galpha.value;
    out.dimV.textContent = el.dim.value;
    out.sdV.textContent = el.sd.value;
  }
  ids.forEach(id=>el[id].addEventListener('input', syncLabels));
  syncLabels();

  // Load via URL param ?src=
  const qs = new URLSearchParams(location.search);
  const src = qs.get('src');
  if(src){ vid.src = src; }

  file.addEventListener('change', e=>{
    const f = e.target.files[0];
    if(!f) return;
    vid.src = URL.createObjectURL(f);
    vid.play();
  });
  playBtn.addEventListener('click', ()=> vid.paused ? vid.play() : vid.pause());

  // Resize canvases to video box
  function fitCanvases(){
    const r = cs.cloud.getBoundingClientRect(); // all share same CSS
    for(const k in cs){
      cs[k].width = Math.max(2, r.width|0);
      cs[k].height = Math.max(2, r.height|0);
    }
  }
  const ro = new ResizeObserver(fitCanvases);
  ro.observe(cs.cloud);

  // Offscreen for analysis
  const proc = document.createElement('canvas');
  const pctx = proc.getContext('2d');

  // State
  let prevPos = null;
  let lastFrame = 0;

  // Utility
  function deg2rad(d){return d*Math.PI/180;}
  function clamp(v,a,b){return Math.max(a,Math.min(b,v));}

  function drawPointCloud(imgData, step, size, alpha, thr, pct){
    const {width:w, height:h, data} = imgData;
    const total = w*h;
    // First pass: brightness histogram to compute dynamic cutoff for top pct%
    const hist = new Uint32Array(256);
    for(let i=0;i<data.length;i+=4){
      const br = data[i]*0.2126 + data[i+1]*0.7152 + data[i+2]*0.0722;
      hist[br|0]++; // floor
    }
    let target = Math.max(1, Math.round(total*(pct/100)));
    let cum=0, cutoff=255;
    for(let b=255;b>=0;b--){
      cum += hist[b];
      if(cum>=target){ cutoff = b; break; }
    }
    const t = Math.max(thr, cutoff); // use stricter of fixed threshold vs top pct

    ctx.cloud.globalAlpha = alpha;
    ctx.cloud.clearRect(0,0,cs.cloud.width,cs.cloud.height);
    ctx.cloud.fillStyle = "#cfe5ff";
    const sx = cs.cloud.width / w, sy = cs.cloud.height / h;

    for(let y=0;y<h;y+=step){
      let row = y*w*4;
      for(let x=0;x<w;x+=step){
        const i = row + x*4;
        const br = data[i]*0.2126 + data[i+1]*0.7152 + data[i+2]*0.0722;
        if(br>=t){
          ctx.cloud.fillRect(Math.round(x*sx), Math.round(y*sy), size, size);
        }
      }
    }
    // Return centroid of bright set
    let sumx=0, sumy=0, cnt=0;
    for(let y=0;y<h;y+=1){
      let row = y*w*4;
      for(let x=0;x<w;x+=1){
        const i = row + x*4;
        const br = data[i]*0.2126 + data[i+1]*0.7152 + data[i+2]*0.0722;
        if(br>=t){ sumx+=x; sumy+=y; cnt++; }
      }
    }
    if(cnt<10) return null;
    return { x: (sumx/cnt)*sx, y: (sumy/cnt)*sy };
  }

  // Trails: decay the existing trail canvas, then draw a segment
  function decayTrails(amount){
    const w=cs.trails.width, h=cs.trails.height;
    ctx.trails.globalCompositeOperation = 'destination-out';
    ctx.trails.fillStyle = `rgba(0,0,0,${1-amount})`;
    ctx.trails.fillRect(0,0,w,h);
    ctx.trails.globalCompositeOperation = 'source-over';
  }

  function drawTrailSegment(p0, p1, w){
    if(!p0||!p1) return;
    ctx.trails.strokeStyle = "#a7c7ff";
    ctx.trails.lineWidth = w;
    ctx.trails.beginPath();
    ctx.trails.moveTo(p0.x,p0.y);
    ctx.trails.lineTo(p1.x,p1.y);
    ctx.trails.stroke();
  }

  function drawSunDot(p, r){
    ctx.hud.clearRect(0,0,cs.hud.width,cs.hud.height);
    if(!p) return;
    ctx.hud.fillStyle = "#ffffff";
    ctx.hud.beginPath(); ctx.hud.arc(p.x, p.y, r, 0, Math.PI*2); ctx.hud.fill();
    ctx.hud.strokeStyle="#7dd3fc"; ctx.hud.lineWidth=1; ctx.hud.stroke();
  }

  function drawGhosts(p, v){
    ctx.ghosts.clearRect(0,0,cs.ghosts.width,cs.ghosts.height);
    const K = +el.k.value;
    if(!p || !v || K<=0) return;
    const baseA = Math.atan2(v.y, v.x);
    const baseM = Math.hypot(v.x, v.y);
    const J = deg2rad(+el.jit.value);
    const Mj = +el.mag.value;
    const H = +el.h.value;
    const alpha = +el.galpha.value;

    ctx.ghosts.globalAlpha = alpha;
    ctx.ghosts.strokeStyle = "#ffdb8a";
    ctx.ghosts.lineWidth = 1.25;

    for(let i=0;i<K;i++){
      const ang = baseA + (Math.random()*2-1)*J;
      const mag = Math.max(0.1, baseM * (1 + (Math.random()*2-1)*Mj));
      const dx = Math.cos(ang)*H*mag;
      const dy = Math.sin(ang)*H*mag;
      ctx.ghosts.beginPath();
      ctx.ghosts.moveTo(p.x, p.y);
      ctx.ghosts.lineTo(p.x+dx, p.y+dy);
      ctx.ghosts.stroke();

      // Optionally commit failed ghosts into trails as fossils
      if(keepChk.checked){
        ctx.trails.globalAlpha = 0.15;
        ctx.trails.strokeStyle = "#ffd48a";
        ctx.trails.lineWidth = 1;
        ctx.trails.beginPath();
        ctx.trails.moveTo(p.x, p.y);
        ctx.trails.lineTo(p.x+dx, p.y+dy);
        ctx.trails.stroke();
        ctx.trails.globalAlpha = 1;
      }
    }
  }

  // Main loop
  function tick(t){
    requestAnimationFrame(tick);
    if(vid.readyState < 2) return;

    // Fit processing canvas to CSS pixels for speed/quality balance
    const w = Math.max(320, cs.cloud.clientWidth|0);
    const h = Math.max(180, cs.cloud.clientHeight|0);
    if(proc.width!==w || proc.height!==h){ proc.width=w; proc.height=h; }

    // Draw dimmed video
    const dim = +el.dim.value;
    for(const k of ["cloud","trails","ghosts","hud"]){
      // ensure canvases match on resize
      if(cs[k].width !== cs.cloud.clientWidth|0) fitCanvases();
    }
    const vw = cs.cloud.width, vh = cs.cloud.height;
    ctx.cloud.save();
    ctx.cloud.globalAlpha = dim;
    ctx.cloud.globalCompositeOperation='source-over';
    ctx.cloud.drawImage(vid, 0,0, vw, vh);
    ctx.cloud.restore();

    // Analysis frame
    pctx.filter = el.blur.value>0 ? `blur(${el.blur.value}px)` : 'none';
    pctx.drawImage(vid, 0,0, w, h);
    const frame = pctx.getImageData(0,0,w,h);

    // Point cloud + centroid
    const centroid = drawPointCloud(
      frame,
      +el.step.value,
      +el.pt.value,
      +el.palpha.value,
      +el.thr.value,
      +el.pct.value
    );

    // Trails decay + segment
    decayTrails(+el.decay.value);
    if(centroid && prevPos){
      drawTrailSegment(prevPos, centroid, +el.tw.value);
    }

    // Ghosts from motion vector
    let motion = null;
    if(centroid && prevPos){
      motion = {x: centroid.x - prevPos.x, y: centroid.y - prevPos.y};
    }
    drawGhosts(centroid, motion);

    // Sun dot
    drawSunDot(centroid, +el.sd.value);

    prevPos = centroid || prevPos;
    lastFrame = t;
  }
  requestAnimationFrame(tick);

  // Save current composite
  snapBtn.addEventListener('click', ()=>{
    // Composite order: cloud(video+cloud), trails, ghosts, hud
    const out = document.createElement('canvas');
    out.width = cs.cloud.width; out.height = cs.cloud.height;
    const ox = out.getContext('2d');
    ox.drawImage(cs.cloud,0,0);
    ox.drawImage(cs.trails,0,0);
    ox.drawImage(cs.ghosts,0,0);
    ox.drawImage(cs.hud,0,0);
    const a = document.createElement('a');
    a.download = 'forking_sun_'+Date.now()+'.png';
    a.href = out.toDataURL('image/png');
    a.click();
  });

})();
</script>
</body>
</html>
