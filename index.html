<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Wind-on-Wall — Ghost Lines + Stain (Hi-Res)</title>
<style>
  :root{--bg:#0b0e12;--fg:#e6eeff;--mut:#90a1bb}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font:14px/1.35 system-ui,Segoe UI,Roboto,Helvetica,Arial}
  .wrap{display:grid;grid-template-columns:340px 1fr;gap:14px;height:100%}
  aside{padding:14px 12px 16px;border-right:1px solid #1a2233;overflow:auto}
  main{position:relative}
  canvas{position:absolute;inset:0;width:100%;height:100%;object-fit:contain;background:#000}
  h1{font-size:16px;margin:0 0 10px}
  fieldset{border:1px solid #1a2233;border-radius:10px;margin:10px 0;padding:10px}
  legend{padding:0 6px;color:#9fb7e8}
  .row{display:flex;align-items:center;gap:8px;margin:8px 0}
  .row label{flex:1;color:var(--mut)}
  .row input[type="range"], .row select{flex:2}
  .btn{appearance:none;border:1px solid #2a3754;background:#121826;color:#cfe1ff;border-radius:8px;padding:6px 10px;cursor:pointer}
  .btn:active{transform:translateY(1px)}
  .kbd{font:12px ui-monospace;background:#121520;border:1px solid #1f2736;border-radius:6px;padding:1px 6px;color:#b8c7e8}
  .small{font-size:12px;color:#93a6c4}
  .hud{position:absolute;top:10px;left:10px;background:rgba(0,0,0,.45);padding:6px 8px;border-radius:8px;font:12px ui-monospace;white-space:pre}
</style>
</head>
<body>
<div class="wrap">
  <aside>
    <h1>Wind-on-Wall — Live</h1>
    <div class="row">
      <input id="file" type="file" accept="video/*">
      <button id="webcam" class="btn">Webcam</button>
      <button id="play" class="btn">Play/Pause</button>
    </div>
    <div class="row small">Or URL param: <span class="kbd">?src=clip.mp4</span> (same-origin or CORS)</div>

    <fieldset>
      <legend>Temporal window</legend>
      <div class="row"><label>Δt (seconds)</label><input id="dt" type="range" min="2" max="10" step="0.5" value="6"><span id="dtV">6.0</span></div>
      <div class="row"><label>Diff threshold</label><input id="thr" type="range" min="4" max="60" value="18"><span id="thrV">18</span></div>
      <div class="row"><label>Grey level</label><input id="grey" type="range" min="60" max="200" value="120"><span id="greyV">120</span></div>
      <div class="row"><label>Pre-blur (px)</label><input id="preblur" type="range" min="0" max="3" value="0"><span id="preblurV">0</span></div>
    </fieldset>

    <fieldset>
      <legend>Ghosts (motion lines)</legend>
      <div class="row"><label>Find edges (Sobel)</label><input id="gFind" type="checkbox" checked></div>
      <div class="row"><label>Edge gain</label><input id="gGain" type="range" min="0.5" max="5" step="0.1" value="2"><span id="gGainV">2.0</span></div>
      <div class="row"><label>Invert edges</label><input id="gInv" type="checkbox"></div>
      <div class="row"><label>Line softness (px)</label><input id="gBlur" type="range" min="0" max="4" value="1"><span id="gBlurV">1</span></div>
      <div class="row"><label>Tint amount</label><input id="gTintAmt" type="range" min="0" max="1" step="0.05" value="0.5"><span id="gTintAmtV">0.50</span></div>
      <div class="row"><label>Tint color</label><input id="gTintCol" type="color" value="#a7d1ff"></div>
      <div class="row"><label>Opacity</label><input id="gAlpha" type="range" min="0.2" max="1" step="0.05" value="0.65"><span id="gAlphaV">0.65</span></div>
      <div class="row"><label>Blend mode</label>
        <select id="gBlend">
          <option value="normal">Normal</option>
          <option value="screen" selected>Screen</option>
          <option value="lighter">Lighter</option>
          <option value="multiply">Multiply</option>
        </select>
      </div>
    </fieldset>

    <fieldset>
      <legend>Stain (residual blotches)</legend>
      <div class="row"><label>Enable stain</label><input id="stainOn" type="checkbox" checked></div>
      <div class="row"><label>Decay</label><input id="decay" type="range" min="0.90" max="0.995" step="0.001" value="0.970"><span id="decayV">0.970</span></div>
      <div class="row"><label>Strength</label><input id="strength" type="range" min="0.1" max="1" step="0.05" value="0.50"><span id="strengthV">0.50</span></div>
      <div class="row"><label>Expand (px)</label><input id="expand" type="range" min="0" max="8" step="1" value="2"><span id="expandV">2</span></div>
      <div class="row"><label>Color</label><input id="sColor" type="color" value="#223b7a"></div>
    </fieldset>

    <fieldset>
      <legend>Export</legend>
      <div class="row">
        <button id="shot" class="btn">Export PNG</button>
        <button id="rec" class="btn">Start/Stop Video</button>
      </div>
      <div class="row small" id="dbg">buffer: 0 | fps —</div>
    </fieldset>
  </aside>

  <main>
    <!-- layers -->
    <canvas id="ghost"></canvas>
    <canvas id="stain"></canvas>
    <canvas id="final"></canvas>
    <div id="hud" class="hud"></div>
  </main>
</div>

<script>
(function(){
  // ---------- Elements ----------
  const can = {
    ghost: document.getElementById('ghost'),
    stain: document.getElementById('stain'),
    final: document.getElementById('final'),
  };
  const gctx = can.ghost.getContext('2d');
  const sctx = can.stain.getContext('2d');
  const fctx = can.final.getContext('2d');

  const file = document.getElementById('file');
  const webcamBtn = document.getElementById('webcam');
  const playBtn = document.getElementById('play');
  const recBtn = document.getElementById('rec');
  const shotBtn = document.getElementById('shot');
  const hud = document.getElementById('hud');
  const dbg = document.getElementById('dbg');

  const ids = ["dt","thr","grey","preblur","gAlpha","gBlur","gTintAmt","gGain","decay","strength","expand"];
  const el  = Object.fromEntries(ids.map(id=>[id, document.getElementById(id)]));
  const out = Object.fromEntries(ids.map(id=>[id+"V", document.getElementById(id+"V")]));
  const gFind   = document.getElementById('gFind');
  const gInv    = document.getElementById('gInv');
  const gBlend  = document.getElementById('gBlend');
  const gTintCol= document.getElementById('gTintCol');
  const stainOn = document.getElementById('stainOn');
  const sColor  = document.getElementById('sColor');

  function sync(){
    out.dtV.textContent = (+el.dt.value).toFixed(1);
    out.thrV.textContent = el.thr.value;
    out.greyV.textContent = el.grey.value;
    out.preblurV.textContent = el.preblur.value;
    out.gAlphaV.textContent = (+el.gAlpha.value).toFixed(2);
    out.gBlurV.textContent = el.gBlur.value;
    out.gTintAmtV.textContent = (+el.gTintAmt.value).toFixed(2);
    out.gGainV.textContent = (+el.gGain.value).toFixed(1);
    out.decayV.textContent = (+el.decay.value).toFixed(3);
    out.strengthV.textContent = (+el.strength.value).toFixed(2);
    out.expandV.textContent = el.expand.value;
  }
  [...ids.map(id=>el[id]), gFind, gInv, gBlend, gTintCol, stainOn, sColor].forEach(x=>x.addEventListener('input', sync));
  sync();

  // ---------- Video ----------
  const vid = document.createElement('video');
  vid.crossOrigin = "anonymous";
  vid.playsInline = true; vid.muted = true; vid.loop = true; vid.preload = "auto";

  const qs = new URLSearchParams(location.search);
  const src = qs.get('src'); if(src){ vid.src = src; }

  let mediaStream = null;
  async function startWebcam(){
    stopWebcam();
    mediaStream = await navigator.mediaDevices.getUserMedia({video:true, audio:false});
    vid.srcObject = mediaStream; await vid.play();
  }
  function stopWebcam(){ if(mediaStream){ mediaStream.getTracks().forEach(t=>t.stop()); mediaStream=null; } }

  file.addEventListener('change', e=>{
    const f = e.target.files[0]; if(!f) return;
    stopWebcam();
    vid.src = URL.createObjectURL(f);
    vid.play();
  });
  playBtn.addEventListener('click', ()=> vid.paused ? vid.play() : vid.pause());
  webcamBtn.addEventListener('click', ()=> startWebcam().catch(e=>alert('Webcam failed: '+e.message)));

  // ---------- HiDPI sizing ----------
  function fit(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const r = can.final.getBoundingClientRect();
    const W = Math.max(2, Math.round(r.width*dpr));
    const H = Math.max(2, Math.round(r.height*dpr));
    for(const k in can){ can[k].width=W; can[k].height=H; }
    proc.width=W; proc.height=H;
    maskCanvas.width=W; maskCanvas.height=H;
    colCanvas.width=W; colCanvas.height=H;
  }
  new ResizeObserver(fit).observe(can.final);

  // ---------- Offscreens ----------
  const proc = document.createElement('canvas');
  const pctx = proc.getContext('2d', {willReadFrequently:true});
  const maskCanvas = document.createElement('canvas');
  const maskCtx = maskCanvas.getContext('2d');
  const colCanvas = document.createElement('canvas');
  const colCtx = colCanvas.getContext('2d');

  // ring buffer full-res
  const buf = []; const MAX_SEC = 14;
  function pushFrame(img, t){
    buf.push({t, data: new Uint8ClampedArray(img.data), w: img.width, h: img.height});
    const cutoff = t - (MAX_SEC + 2);
    while(buf.length && buf[0].t < cutoff) buf.shift();
  }
  function getPastFrame(delta){
    const target = vid.currentTime - delta;
    for(let i=buf.length-1;i>=0;i--){ if(buf[i].t <= target) return buf[i]; }
    return buf[0] || null;
  }

  function drawVideoContained(ctx, video, W, H, blurPx){
    ctx.save();
    ctx.clearRect(0,0,W,H);
    if(blurPx>0) ctx.filter = `blur(${blurPx}px)`;
    const vw=video.videoWidth||0, vh=video.videoHeight||0;
    if(vw && vh){
      const s = Math.min(W/vw, H/vh);
      const dw = Math.round(vw*s), dh = Math.round(vh*s);
      const dx = Math.floor((W-dw)/2), dy = Math.floor((H-dh)/2);
      ctx.drawImage(video, dx,dy,dw,dh);
    }
    ctx.restore();
  }
  function hexRGB(hex){
    const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return m ? [parseInt(m[1],16), parseInt(m[2],16), parseInt(m[3],16)] : [255,255,255];
  }

  // ---------- Recording / PNG ----------
  let recorder=null, chunks=[];
  recBtn.addEventListener('click', ()=>{
    if(recorder && recorder.state==='recording'){ recorder.stop(); return; }
    chunks = [];
    const stream = can.final.captureStream ? can.final.captureStream(30) : can.final.mozCaptureStream(30);
    recorder = new MediaRecorder(stream, {mimeType:'video/webm;codecs=vp9'});
    recorder.ondataavailable = e=>{ if(e.data.size) chunks.push(e.data); };
    recorder.onstop = ()=>{
      const blob = new Blob(chunks, {type:'video/webm'});
      const a = document.createElement('a');
      a.download = 'wind_on_wall_'+Date.now()+'.webm';
      a.href = URL.createObjectURL(blob);
      a.click();
    };
    recorder.start();
  });
  shotBtn.addEventListener('click', ()=>{
    const a = document.createElement('a');
    a.download = 'still_'+Date.now()+'.png';
    a.href = can.final.toDataURL('image/png');
    a.click();
  });

  // ---------- Main loop ----------
  let lastT=0, fpsEMA=0;
  function tick(now){
    requestAnimationFrame(tick);
    if(vid.readyState < 2) return;

    const W = can.final.width, H = can.final.height;

    // 1) draw current frame
    drawVideoContained(pctx, vid, W, H, +el.preblur.value);
    const curr = pctx.getImageData(0,0,W,H);
    pushFrame(curr, vid.currentTime);

    // 2) past frame
    const past = getPastFrame(+el.dt.value);
    if(!past) return;

    // 3) diff mask + AE invert-blend ghost base
    const c = curr.data, p = past.data;
    const thr = +el.thr.value, grey = +el.grey.value;
    const tintAmt = +el.gTintAmt.value;
    const [tr,tg,tb] = hexRGB(gTintCol.value);

    const ghostBase = gctx.createImageData(W,H);
    const gb = ghostBase.data;
    const mask = new Uint8ClampedArray(W*H);
    let changedCount=0;

    for(let i=0,j=0;i<c.length;i+=4,j++){
      const r=c[i], g=c[i+1], b=c[i+2];
      const pr=p[i], pg=p[i+1], pb=p[i+2];
      const lc = r*0.2126 + g*0.7152 + b*0.0722;
      const lp = pr*0.2126 + pg*0.7152 + pb*0.0722;
      const d = Math.abs(lc - lp);

      if(d > thr){
        changedCount++; mask[j]=255;
        // AE-style invert-blend
        let R = (r + (255 - pr)) * 0.5;
        let G = (g + (255 - pg)) * 0.5;
        let B = (b + (255 - pb)) * 0.5;
        if(tintAmt>0){
          const Y = R*0.2126 + G*0.7152 + B*0.0722;
          R = R*(1-tintAmt) + (tr*(Y/255))*(tintAmt);
          G = G*(1-tintAmt) + (tg*(Y/255))*(tintAmt);
          B = B*(1-tintAmt) + (tb*(Y/255))*(tintAmt);
        }
        gb[i]=R; gb[i+1]=G; gb[i+2]=B; gb[i+3]=255;
      } else {
        gb[i]=grey; gb[i+1]=grey; gb[i+2]=grey; gb[i+3]=255;
      }
    }

    // 4) FIND EDGES over the ghostBase (Sobel on luminance)
    let ghostToDraw = ghostBase; // default
    if(document.getElementById('gFind').checked){
      // luminance buffer of ghostBase
      const L = new Float32Array(W*H);
      for(let i=0,j=0;i<gb.length;i+=4,j++){
        L[j] = gb[i]*0.2126 + gb[i+1]*0.7152 + gb[i+2]*0.0722;
      }
      const gain = +el.gGain.value;
      const inv = document.getElementById('gInv').checked;
      const edgeImg = gctx.createImageData(W,H);
      const ed = edgeImg.data;

      // Sobel
      for(let y=1;y<H-1;y++){
        for(let x=1;x<W-1;x++){
          const j = y*W + x;
          if(mask[j]===0){
            // unchanged area -> grey
            const i = j*4;
            ed[i]=grey; ed[i+1]=grey; ed[i+2]=grey; ed[i+3]=255;
            continue;
          }
          const a=L[j-W-1], b=L[j-W], c1=L[j-W+1];
          const d1=L[j-1],   f=L[j+1];
          const g1=L[j+W-1], h=L[j+W], i1=L[j+W+1];

          const Gx = -a -2*d1 - g1 + c1 + 2*f + i1;
          const Gy = -a -2*b - c1 + g1 + 2*h + i1;
          let mag = Math.sqrt(Gx*Gx + Gy*Gy);   // ~0..~1440
          let e = Math.min(255, (mag * gain) / 4); // scale
          if(inv) e = 255 - e;

          // tint edge intensity
          const amt = tintAmt;
          const Rt = (1-amt)*e + amt*(tr*(e/255));
          const Gt = (1-amt)*e + amt*(tg*(e/255));
          const Bt = (1-amt)*e + amt*(tb*(e/255));

          const ii = j*4;
          ed[ii]=Rt; ed[ii+1]=Gt; ed[ii+2]=Bt; ed[ii+3]=255;
        }
      }

      ghostToDraw = edgeImg;
    }

    // paint ghost layer
    gctx.putImageData(ghostToDraw,0,0);

    // optional ghost line softness
    if(+el.gBlur.value>0){
      gctx.filter = `blur(${+el.gBlur.value}px)`;
      // redraw blurred onto itself
      const tmp = document.createElement('canvas');
      tmp.width=W; tmp.height=H;
      tmp.getContext('2d').drawImage(can.ghost,0,0);
      gctx.filter='none';
      gctx.clearRect(0,0,W,H);
      gctx.drawImage(tmp,0,0);
    }

    // 5) STAIN (solid blotches) — uses FULL mask (not edges)
    if(stainOn.checked){
      const decay = +el.decay.value;
      sctx.globalCompositeOperation='destination-out';
      sctx.fillStyle = `rgba(0,0,0,${1-decay})`;
      sctx.fillRect(0,0,W,H);
      sctx.globalCompositeOperation='source-over';

      // mask → canvas
      const mImg = maskCtx.createImageData(W,H);
      const mdat = mImg.data;
      for(let j=0,k=0;j<mask.length;j++,k+=4){
        const v = mask[j];
        mdat[k]=mdat[k+1]=mdat[k+2]=v; mdat[k+3]=v;
      }
      maskCtx.putImageData(mImg,0,0);

      // expand & colorize
      colCtx.clearRect(0,0,W,H);
      const expand = +el.expand.value;
      if(expand>0){ colCtx.filter = `blur(${expand}px)`; }
      colCtx.drawImage(maskCanvas,0,0);
      colCtx.filter='none';
      colCtx.globalCompositeOperation='source-in';
      colCtx.fillStyle = sColor.value;
      colCtx.globalAlpha = +el.strength.value;
      colCtx.fillRect(0,0,W,H);
      colCtx.globalCompositeOperation='source-over';
      colCtx.globalAlpha = 1;

      sctx.drawImage(colCanvas,0,0);
    }

    // 6) FINAL COMPOSITE: grey base → ghosts (blend/alpha) → stain (multiply)
    fctx.clearRect(0,0,W,H);
    const grey = +el.grey.value;
    fctx.fillStyle = `rgb(${grey},${grey},${grey})`;
    fctx.fillRect(0,0,W,H);

    fctx.globalAlpha = +el.gAlpha.value;
    fctx.globalCompositeOperation = gBlend.value;
    fctx.drawImage(can.ghost,0,0);
    fctx.globalAlpha = 1;

    if(stainOn.checked){
      fctx.globalCompositeOperation='multiply';
      fctx.drawImage(can.stain,0,0);
    }
    fctx.globalCompositeOperation='source-over';

    // HUD / debug
    const dt = now - lastT; lastT = now;
    const inst = dt>0 ? 1000/dt : 0; fpsEMA = fpsEMA? fpsEMA*0.9 + inst*0.1 : inst;
    const pct = 100*(changedCount/(W*H));
    hud.textContent = `Δt = ${(+el.dt.value).toFixed(1)} s
thr=${el.thr.value}, pre-blur=${el.preblur.value}, grey=${el.grey.value}
ghost: find=${gFind.checked?'on':'off'}, gain=${(+el.gGain.value).toFixed(1)}, invert=${gInv.checked}, α=${(+el.gAlpha.value).toFixed(2)}, blend=${gBlend.value}
stain: ${stainOn.checked?'on':'off'} decay=${(+el.decay.value).toFixed(3)}, expand=${el.expand.value}, strength=${(+el.strength.value).toFixed(2)}
changed=${pct.toFixed(1)}%`;
    dbg.textContent = `buffer: ${buf.length} | fps ~ ${fpsEMA.toFixed(1)}`;
  }
  requestAnimationFrame(tick);

  vid.addEventListener('loadeddata', ()=>{ vid.play().catch(()=>{}); });
})();
</script>
</body>
</html>
