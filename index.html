<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Forking Sun — Ghost Paths (Point-Cloud)</title>
<style>
  :root{--bg:#0a0a0c;--fg:#d8e6ff;--mut:#7f8ea3}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font:14px/1.35 system-ui,Segoe UI,Roboto,Helvetica,Arial}
  .wrap{display:grid;grid-template-columns:320px 1fr;gap:14px;height:100%}
  aside{padding:14px 12px 16px;border-right:1px solid #1a1f2a;overflow:auto}
  main{position:relative}
  canvas,video{position:absolute;inset:0;width:100%;height:100%;object-fit:contain;background:#000}
  video{opacity:.15}
  .layers{position:absolute;inset:0}
  h1{font-size:16px;margin:0 0 10px}
  fieldset{border:1px solid #1c2533;border-radius:10px;margin:10px 0;padding:10px}
  legend{padding:0 6px;color:#9fb4d4}
  .row{display:flex;align-items:center;gap:8px;margin:9px 0}
  .row label{flex:1;color:var(--mut)}
  .row input[type="range"]{flex:2}
  .small{font-size:12px;color:#9aa8c0}
  .btn{appearance:none;border:1px solid #2a3650;background:#121725;color:#cfe3ff;border-radius:8px;padding:6px 10px;cursor:pointer}
  .btn:active{transform:translateY(1px)}
  .kbd{font:12px/1.2 ui-monospace,Menlo,Consolas;background:#121520;border:1px solid #1f2734;border-radius:6px;padding:1px 6px;color:#b8c7e8}
</style>
</head>
<body>
<div class="wrap">
  <aside>
    <h1>Forking Sun — Ghost Paths</h1>
    <div class="row">
      <input id="file" type="file" accept="video/*">
      <button id="play" class="btn">Play/Pause</button>
    </div>
    <div class="row small">Or URL param: <span class="kbd">?src=your.mp4</span></div>

    <fieldset>
      <legend>Detection</legend>
      <div class="row"><label>Brightness threshold</label><input id="thr" type="range" min="0" max="255" value="110"><span id="thrV">110</span></div>
      <div class="row"><label>Blur (px)</label><input id="blur" type="range" min="0" max="6" value="2"><span id="blurV">2</span></div>
      <div class="row"><label>Mask % (top bright)</label><input id="pct" type="range" min="0.1" max="60" step="0.1" value="8"><span id="pctV">8.0%</span></div>
      <div class="row"><label>Use frame difference</label><input id="useDiff" type="checkbox"></div>
      <div class="row"><label>Diff threshold</label><input id="dthr" type="range" min="2" max="80" value="16"><span id="dthrV">16</span></div>
    </fieldset>

    <fieldset>
      <legend>Point-Cloud</legend>
      <div class="row"><label>Point size</label><input id="pt" type="range" min="1" max="6" value="2"><span id="ptV">2</span></div>
      <div class="row"><label>Cloud opacity</label><input id="palpha" type="range" min="0" max="1" step="0.01" value="0.6"><span id="palphaV">0.60</span></div>
      <div class="row"><label>Sample step (px)</label><input id="step" type="range" min="1" max="6" value="2"><span id="stepV">2</span></div>
    </fieldset>

    <fieldset>
      <legend>Trails (Past)</legend>
      <div class="row"><label>Trail decay</label><input id="decay" type="range" min="0.80" max="0.995" step="0.001" value="0.96"><span id="decayV">0.96</span></div>
      <div class="row"><label>Trail weight</label><input id="tw" type="range" min="0.5" max="4" step="0.1" value="2"><span id="twV">2</span></div>
    </fieldset>

    <fieldset>
      <legend>Ghosts (Future)</legend>
      <div class="row"><label># Branches</label><input id="k" type="range" min="0" max="8" value="4"><span id="kV">4</span></div>
      <div class="row"><label>Horizon (px)</label><input id="h" type="range" min="10" max="300" value="140"><span id="hV">140</span></div>
      <div class="row"><label>Angle jitter (°)</label><input id="jit" type="range" min="0" max="45" value="18"><span id="jitV">18</span></div>
      <div class="row"><label>Magnitude jitter</label><input id="mag" type="range" min="0" max="1" step="0.01" value="0.25"><span id="magV">0.25</span></div>
      <div class="row"><label>Ghost opacity</label><input id="galpha" type="range" min="0" max="1" step="0.01" value="0.28"><span id="galphaV">0.28</span></div>
      <div class="row"><label>Keep failed ghosts</label><input id="keep" type="checkbox" checked></div>
    </fieldset>

    <fieldset>
      <legend>Render</legend>
      <div class="row"><label>Dim video</label><input id="dim" type="range" min="0" max="1" step="0.01" value="0.85"><span id="dimV">0.85</span></div>
      <div class="row"><label>Sun dot size</label><input id="sd" type="range" min="2" max="10" value="5"><span id="sdV">5</span></div>
      <div class="row"><button id="snap" class="btn">Save Frame (PNG)</button></div>
    </fieldset>

    <div class="small">Tip: For one-dot issue, try Mask ≥ 8–20% and/or enable <b>Use frame difference</b>.</div>
  </aside>

  <main>
    <video id="vid" playsinline muted loop></video>
    <div class="layers">
      <canvas id="cloud"></canvas>
      <canvas id="trails"></canvas>
      <canvas id="ghosts"></canvas>
      <canvas id="hud"></canvas>
    </div>
  </main>
</div>

<script>
(function(){
  // Elements
  const vid = document.getElementById('vid');
  const file = document.getElementById('file');
  const playBtn = document.getElementById('play');
  const cs = {
    cloud: document.getElementById('cloud'),
    trails: document.getElementById('trails'),
    ghosts: document.getElementById('ghosts'),
    hud: document.getElementById('hud')
  };
  const ctx = Object.fromEntries(Object.entries(cs).map(([k,c])=>[k,c.getContext('2d')]));

  const ids = ["thr","blur","pct","pt","palpha","step","decay","tw","k","h","jit","mag","galpha","dim","sd","dthr"];
  const el = Object.fromEntries(ids.map(id=>[id, document.getElementById(id)]));
  const out = Object.fromEntries(ids.map(id=>[id+"V", document.getElementById(id+"V")]));
  const useDiff = document.getElementById('useDiff');
  const keepChk = document.getElementById('keep');
  const snapBtn = document.getElementById('snap');

  function syncLabels(){
    out.thrV.textContent = el.thr.value;
    out.blurV.textContent = el.blur.value;
    out.pctV.textContent = (+el.pct.value).toFixed(1) + "%";
    out.ptV.textContent = el.pt.value;
    out.palphaV.textContent = (+el.palpha.value).toFixed(2);
    out.stepV.textContent = el.step.value;
    out.decayV.textContent = el.decay.value;
    out.twV.textContent = el.tw.value;
    out.kV.textContent = el.k.value;
    out.hV.textContent = el.h.value;
    out.jitV.textContent = el.jit.value;
    out.magV.textContent = el.mag.value;
    out.galphaV.textContent = (+el.galpha.value).toFixed(2);
    out.dimV.textContent = (+el.dim.value).toFixed(2);
    out.sdV.textContent = el.sd.value;
    out.dthrV.textContent = el.dthr.value;
  }
  ids.forEach(id=>el[id].addEventListener('input', syncLabels));
  useDiff.addEventListener('change', syncLabels);
  syncLabels();

  // URL ?src=
  const qs = new URLSearchParams(location.search);
  const src = qs.get('src'); if(src){ vid.src = src; }
  file.addEventListener('change', e=>{
    const f = e.target.files[0]; if(!f) return;
    vid.src = URL.createObjectURL(f); vid.play();
  });

  // Play button (optional)
  if(playBtn) playBtn.addEventListener('click', ()=> vid.paused ? vid.play() : vid.pause());

  // Resize
  function fit(){
    const r = cs.cloud.getBoundingClientRect();
    for(const k in cs){ cs[k].width = Math.max(2, r.width|0); cs[k].height = Math.max(2, r.height|0); }
  }
  new ResizeObserver(fit).observe(cs.cloud);

  // Processing canvas
  const proc = document.createElement('canvas');
  const pctx = proc.getContext('2d', {willReadFrequently:true});
  let prevGray = null;

  // Utils
  function deg2rad(d){return d*Math.PI/180;}

  // Trails management
  function decayTrails(amount){
    const w=cs.trails.width, h=cs.trails.height;
    ctx.trails.globalCompositeOperation = 'destination-out';
    ctx.trails.fillStyle = `rgba(0,0,0,${1-amount})`;
    ctx.trails.fillRect(0,0,w,h);
    ctx.trails.globalCompositeOperation = 'source-over';
  }
  function drawTrail(p0,p1,w){
    if(!p0||!p1) return;
    ctx.trails.strokeStyle = "#a7c7ff";
    ctx.trails.lineWidth = w;
    ctx.trails.beginPath(); ctx.trails.moveTo(p0.x,p0.y); ctx.trails.lineTo(p1.x,p1.y); ctx.trails.stroke();
  }
  function drawDot(p, r){
    ctx.hud.clearRect(0,0,cs.hud.width,cs.hud.height);
    if(!p) return;
    ctx.hud.fillStyle="#fff"; ctx.hud.beginPath(); ctx.hud.arc(p.x,p.y,r,0,Math.PI*2); ctx.hud.fill();
    ctx.hud.strokeStyle="#7dd3fc"; ctx.hud.lineWidth=1; ctx.hud.stroke();
  }
  function drawGhosts(p, v){
    ctx.ghosts.clearRect(0,0,cs.ghosts.width,cs.ghosts.height);
    if(!p || !v) return;
    const K=+el.k.value, J=deg2rad(+el.jit.value), Mj=+el.mag.value, H=+el.h.value, alpha=+el.galpha.value;
    if(K<=0) return;
    const baseA = Math.atan2(v.y,v.x), baseM = Math.hypot(v.x,v.y);
    ctx.ghosts.globalAlpha = alpha; ctx.ghosts.strokeStyle="#ffdb8a"; ctx.ghosts.lineWidth=1.25;
    for(let i=0;i<K;i++){
      const ang = baseA + (Math.random()*2-1)*J;
      const mag = Math.max(0.1, baseM*(1+(Math.random()*2-1)*Mj));
      const dx = Math.cos(ang)*H*mag, dy = Math.sin(ang)*H*mag;
      ctx.ghosts.beginPath(); ctx.ghosts.moveTo(p.x,p.y); ctx.ghosts.lineTo(p.x+dx,p.y+dy); ctx.ghosts.stroke();
      if(keepChk.checked){
        ctx.trails.globalAlpha = 0.15; ctx.trails.strokeStyle="#ffd48a"; ctx.trails.lineWidth=1;
        ctx.trails.beginPath(); ctx.trails.moveTo(p.x,p.y); ctx.trails.lineTo(p.x+dx,p.y+dy); ctx.trails.stroke();
        ctx.trails.globalAlpha = 1;
      }
    }
  }

  // Centroid + cloud draw using UNION mask
  function pointCloudAndCentroid(srcImg, useDiffMask){
    const {width:w, height:h, data} = srcImg;
    const step = +el.step.value, size = +el.pt.value, alpha = +el.palpha.value;
    // Compute grayscale and (optional) diff
    const gray = new Uint8ClampedArray(w*h);
    for(let i=0, j=0;i<data.length;i+=4,j++){
      gray[j] = data[i]*0.2126 + data[i+1]*0.7152 + data[i+2]*0.0722;
    }

    // Histogram for top-pct
    let cutoff = 255;
    if(!useDiffMask){
      const hist = new Uint32Array(256);
      for(let i=0;i<gray.length;i++) hist[gray[i]]++;
      const target = Math.max(1, Math.round(w*h * (+el.pct.value/100)));
      let cum=0;
      for(let b=255;b>=0;b--){ cum+=hist[b]; if(cum>=target){ cutoff=b; break; } }
    }

    // If using diff, build absolute difference to previous frame
    let diff = null;
    if(useDiffMask){
      diff = new Uint8ClampedArray(w*h);
      if(prevGray){
        const t = +el.dthr.value;
        for(let i=0;i<gray.length;i++){
          const d = Math.abs(gray[i] - prevGray[i]);
          diff[i] = d > t ? 255 : 0;
        }
      } else {
        diff.fill(0);
      }
      prevGray = gray;
    } else {
      prevGray = gray; // keep for later toggles
    }

    const thr = +el.thr.value;
    const unionCut = Math.min(thr, cutoff); // UNION of rules (fix)
    const sx = cs.cloud.width / w, sy = cs.cloud.height / h;

    // draw cloud
    ctx.cloud.globalAlpha = alpha;
    ctx.cloud.clearRect(0,0,cs.cloud.width,cs.cloud.height);
    ctx.cloud.fillStyle = "#cfe5ff";

    let sumx=0,sumy=0,cnt=0;

    // stride for drawing
    for(let y=0;y<h;y+=step){
      for(let x=0;x<w;x+=step){
        const i = y*w + x;
        let keep=false;
        if(useDiffMask){
          keep = diff[i]===255 || gray[i]>=unionCut; // allow motion OR bright
        } else {
          keep = gray[i]>=unionCut;
        }
        if(keep){
          ctx.cloud.fillRect(Math.round(x*sx), Math.round(y*sy), size, size);
        }
      }
    }
    // centroid at full res for stability
    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        const i = y*w + x;
        let keep=false;
        if(useDiffMask){
          keep = diff[i]===255 || gray[i]>=unionCut;
        } else {
          keep = gray[i]>=unionCut;
        }
        if(keep){ sumx+=x; sumy+=y; cnt++; }
      }
    }
    if(cnt<10) return null;
    return { x:(sumx/cnt)*sx, y:(sumy/cnt)*sy };
  }

  let prevPos = null;

  // Main loop
  function tick(){
    requestAnimationFrame(tick);
    if(vid.readyState < 2) return;

    // Fit processing size (kept moderate for speed)
    const w = Math.max(320, cs.cloud.clientWidth|0);
    const h = Math.max(180, cs.cloud.clientHeight|0);
    if(proc.width!==w || proc.height!==h){ proc.width=w; proc.height=h; }

    // Draw dimmed video below
    const dim = +el.dim.value;
    ctx.cloud.save();
    ctx.cloud.globalAlpha = dim;
    ctx.cloud.globalCompositeOperation='source-over';
    ctx.cloud.drawImage(vid, 0,0, cs.cloud.width, cs.cloud.height);
    ctx.cloud.restore();

    // Analysis frame (with optional blur)
    pctx.filter = (+el.blur.value>0) ? `blur(${el.blur.value}px)` : 'none';
    pctx.drawImage(vid, 0,0, w, h);
    const frame = pctx.getImageData(0,0,w,h);

    // Cloud + centroid
    const centroid = pointCloudAndCentroid(frame, useDiff.checked);

    // Trails + ghosts + dot
    decayTrails(+el.decay.value);
    if(centroid && prevPos) drawTrail(prevPos, centroid, +el.tw.value);
    const motion = (centroid && prevPos) ? {x:centroid.x-prevPos.x, y:centroid.y-prevPos.y} : null;
    drawGhosts(centroid, motion);
    drawDot(centroid, +el.sd.value);

    if(centroid) prevPos = centroid;
  }
  requestAnimationFrame(tick);

  // Save composite PNG
  snapBtn.addEventListener('click', ()=>{
    const out = document.createElement('canvas');
    out.width = cs.cloud.width; out.height = cs.cloud.height;
    const ox = out.getContext('2d');
    ox.drawImage(cs.cloud,0,0);
    ox.drawImage(cs.trails,0,0);
    ox.drawImage(cs.ghosts,0,0);
    ox.drawImage(cs.hud,0,0);
    const a = document.createElement('a');
    a.download = 'forking_sun_'+Date.now()+'.png';
    a.href = out.toDataURL('image/png');
    a.click();
  });

  // Autoplay on src= param
  vid.addEventListener('loadeddata', ()=>{ vid.play().catch(()=>{}); });
})();
</script>
</body>
</html>

