<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Motion Window — Show Only What Moved</title>
<style>
  :root{--bg:#0b0e12;--fg:#dfe9ff;--mut:#8ea0ba}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font:14px/1.35 system-ui,Segoe UI,Roboto,Helvetica,Arial}
  .wrap{display:grid;grid-template-columns:320px 1fr;gap:14px;height:100%}
  aside{padding:14px 12px 16px;border-right:1px solid #1a2233;overflow:auto}
  main{position:relative}
  video,canvas{position:absolute;inset:0;width:100%;height:100%;object-fit:contain}
  #view{background:#000}
  h1{font-size:16px;margin:0 0 10px}
  fieldset{border:1px solid #1a2233;border-radius:10px;margin:10px 0;padding:10px}
  legend{padding:0 6px;color:#9fb7e8}
  .row{display:flex;align-items:center;gap:8px;margin:9px 0}
  .row label{flex:1;color:var(--mut)}
  .row input[type="range"]{flex:2}
  .btn{appearance:none;border:1px solid #2a3754;background:#121826;color:#cfe1ff;border-radius:8px;padding:6px 10px;cursor:pointer}
  .btn:active{transform:translateY(1px)}
  .small{font-size:12px;color:#93a6c4}
  .kbd{font:12px/1.2 ui-monospace,Menlo,Consolas;background:#121520;border:1px solid #1f2736;border-radius:6px;padding:1px 6px;color:#b8c7e8}
</style>
</head>
<body>
<div class="wrap">
  <aside>
    <h1>Motion Window — Show Only What Moved</h1>
    <div class="row">
      <input id="file" type="file" accept="video/*">
      <button id="play" class="btn">Play/Pause</button>
    </div>
    <div class="row small">Or URL param: <span class="kbd">?src=clip.mp4</span></div>

    <fieldset>
      <legend>Motion Window</legend>
      <div class="row"><label>Window Δt (s)</label><input id="win" type="range" min="2" max="10" step="0.5" value="4"><span id="winV">4.0</span></div>
      <div class="row"><label>Mode</label>
        <select id="mode">
          <option value="diff" selected>Diff Mask (grey background)</option>
          <option value="invert">Invert-Blend (masked)</option>
        </select>
      </div>
      <div class="row"><label>Diff threshold</label><input id="thr" type="range" min="4" max="80" value="18"><span id="thrV">18</span></div>
      <div class="row"><label>Blur (px)</label><input id="blur" type="range" min="0" max="4" value="1"><span id="blurV">1</span></div>
      <div class="row"><label>Neutral grey</label><input id="grey" type="range" min="0" max="255" value="120"><span id="greyV">120</span></div>
      <div class="row"><label>Resolution scale</label><input id="scale" type="range" min="0.3" max="1" step="0.05" value="0.7"><span id="scaleV">0.70</span></div>
      <div class="row small" id="dbg">buffer: 0 frames | fps ~ —</div>
    </fieldset>

    <fieldset>
      <legend>Export</legend>
      <div class="row"><button id="shot" class="btn">Save PNG</button></div>
    </fieldset>

    <div class="small">
      Tip: raise <b>Δt</b> to catch slow drifts; lower <b>thr</b> if motion is subtle; increase <b>scale</b> for sharper output (heavier CPU).
    </div>
  </aside>

  <main>
    <canvas id="view"></canvas>
  </main>
</div>

<script>
(function(){
  // Elements
  const file = document.getElementById('file');
  const playBtn = document.getElementById('play');
  const shotBtn = document.getElementById('shot');
  const view = document.getElementById('view');
  const vctx = view.getContext('2d');

  const win = document.getElementById('win');
  const thr = document.getElementById('thr');
  const blur = document.getElementById('blur');
  const grey = document.getElementById('grey');
  const scale = document.getElementById('scale');
  const mode = document.getElementById('mode');

  const winV = document.getElementById('winV');
  const thrV = document.getElementById('thrV');
  const blurV = document.getElementById('blurV');
  const greyV = document.getElementById('greyV');
  const scaleV = document.getElementById('scaleV');
  const dbg = document.getElementById('dbg');

  function sync(){
    winV.textContent = (+win.value).toFixed(1);
    thrV.textContent = thr.value;
    blurV.textContent = blur.value;
    greyV.textContent = grey.value;
    scaleV.textContent = (+scale.value).toFixed(2);
  }
  [win,thr,blur,grey,scale,mode].forEach(e=>e.addEventListener('input', sync));
  sync();

  // Video setup
  const vid = document.createElement('video');
  vid.crossOrigin = "anonymous";
  vid.playsInline = true; vid.muted = true; vid.loop = true; vid.preload = "auto";

  // Load via query ?src=
  const qs = new URLSearchParams(location.search);
  const src = qs.get('src');
  if(src) vid.src = src;

  // File picker
  file.addEventListener('change', e=>{
    const f = e.target.files[0]; if(!f) return;
    vid.src = URL.createObjectURL(f);
    vid.play();
  });
  playBtn.addEventListener('click', ()=> vid.paused ? vid.play() : vid.pause());

  // Processing buffers (downscaled to save CPU)
  const proc = document.createElement('canvas');
  const pctx = proc.getContext('2d', {willReadFrequently:true});

  // Ring buffer of past frames: {t, data (Uint8ClampedArray), w,h}
  const buf = [];
  const MAX_SEC = 12; // keep a bit more than max window
  let lastTime = 0, fpsEMA = 0;

  function pushFrame(imgData, t){
    buf.push({t, data: new Uint8ClampedArray(imgData.data), w: imgData.width, h: imgData.height});
    // drop old
    const cutoff = t - (MAX_SEC+2);
    while(buf.length && buf[0].t < cutoff) buf.shift();
  }
  function getPastFrame(tDelta){
    const target = vid.currentTime - tDelta;
    // find the closest frame at/just before target
    for(let i=buf.length-1; i>=0; i--){
      if(buf[i].t <= target) return buf[i];
    }
    return buf[0] || null;
  }

  function resize(){
    const rect = view.getBoundingClientRect();
    view.width = Math.max(2, rect.width|0);
    view.height = Math.max(2, rect.height|0);
  }
  new ResizeObserver(resize).observe(view);

  function tick(now){
    requestAnimationFrame(tick);
    if(vid.readyState < 2) return;

    // Downscaled analysis size
    const s = +scale.value;
    const aw = Math.max(160, Math.round(view.width * s));
    const ah = Math.max(90,  Math.round(view.height* s));
    if(proc.width!==aw || proc.height!==ah){ proc.width=aw; proc.height=ah; }

    // Draw current frame to analysis canvas (with optional blur)
    pctx.filter = (+blur.value>0) ? `blur(${blur.value}px)` : 'none';
    pctx.drawImage(vid, 0, 0, aw, ah);
    const curr = pctx.getImageData(0, 0, aw, ah);
    pushFrame(curr, vid.currentTime);

    // Find past frame by Δt
    const past = getPastFrame(+win.value);
    if(!past) return;

    // Compose output: show only change; static areas to grey
    const out = vctx.createImageData(view.width, view.height);
    const sx = view.width/aw, sy = view.height/ah;

    // We render in tiles to avoid per-pixel drawImage overhead: compute at analysis scale then scale up
    // So build a small ImageData first:
    const small = new ImageData(aw, ah);
    const th = +thr.value;
    const g  = +grey.value;

    const c = curr.data, p = past.data, o = small.data;
    const useInvert = (mode.value === 'invert');

    for(let i=0;i<c.length;i+=4){
      const r=c[i], g1=c[i+1], b=c[i+2];
      const pr=p[i], pg=p[i+1], pb=p[i+2];

      // luminance difference (0..255)
      const lc = r*0.2126 + g1*0.7152 + b*0.0722;
      const lp = pr*0.2126 + pg*0.7152 + pb*0.0722;
      const d = Math.abs(lc - lp);

      if(d > th){
        if(useInvert){
          // 0.5*curr + 0.5*(255 - past)
          o[i]   = (r + (255 - pr)) * 0.5;
          o[i+1] = (g1 + (255 - pg)) * 0.5;
          o[i+2] = (b + (255 - pb)) * 0.5;
          o[i+3] = 255;
        }else{
          // show current color
          o[i]=r; o[i+1]=g1; o[i+2]=b; o[i+3]=255;
        }
      }else{
        // neutral grey
        o[i]=g; o[i+1]=g; o[i+2]=g; o[i+3]=255;
      }
    }

    // Paint small → scale up to view
    // First clear
    vctx.clearRect(0,0,view.width,view.height);
    // Put small into an offscreen canvas then draw scaled
    const tmp = document.createElement('canvas');
    tmp.width = aw; tmp.height = ah;
    const tctx = tmp.getContext('2d');
    tctx.putImageData(small, 0, 0);
    vctx.imageSmoothingEnabled = true;
    vctx.drawImage(tmp, 0, 0, view.width, view.height);

    // FPS/debug
    const dt = now - lastTime; lastTime = now;
    const inst = dt>0 ? 1000/dt : 0; fpsEMA = fpsEMA? fpsEMA*0.9 + inst*0.1 : inst;
    dbg.textContent = `buffer: ${buf.length} frames | fps ~ ${fpsEMA.toFixed(1)} | Δt=${(+win.value).toFixed(1)}s | thr=${th}`;
  }
  requestAnimationFrame(tick);

  // Save PNG of current output
  document.getElementById('shot').addEventListener('click', ()=>{
    const a = document.createElement('a');
    a.download = 'motion_window_'+Date.now()+'.png';
    a.href = view.toDataURL('image/png');
    a.click();
  });

  // autoplay on src
  vid.addEventListener('loadeddata', ()=>{ vid.play().catch(()=>{}); });
})();
</script>
</body>
</html>
