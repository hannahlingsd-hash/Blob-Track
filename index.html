<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Wind-on-Wall — Invert-Blend + Residual Staining</title>
<style>
  :root{--bg:#0b0e12;--fg:#e6eeff;--mut:#8ea0ba}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font:14px/1.35 system-ui,Segoe UI,Roboto,Helvetica,Arial}
  .wrap{display:grid;grid-template-columns:320px 1fr;gap:14px;height:100%}
  aside{padding:14px 12px 16px;border-right:1px solid #1a2233;overflow:auto}
  main{position:relative}
  canvas{position:absolute;inset:0;width:100%;height:100%;object-fit:contain;background:#000}
  h1{font-size:16px;margin:0 0 10px}
  fieldset{border:1px solid #1a2233;border-radius:10px;margin:10px 0;padding:10px}
  legend{padding:0 6px;color:#9fb7e8}
  .row{display:flex;align-items:center;gap:8px;margin:8px 0}
  .row label{flex:1;color:var(--mut)}
  .row input[type="range"]{flex:2}
  .btn{appearance:none;border:1px solid #2a3754;background:#121826;color:#cfe1ff;border-radius:8px;padding:6px 10px;cursor:pointer}
  .btn:active{transform:translateY(1px)}
  .small{font-size:12px;color:#93a6c4}
  .kbd{font:12px/1.2 ui-monospace,Menlo,Consolas;background:#121520;border:1px solid #1f2736;border-radius:6px;padding:1px 6px;color:#b8c7e8}
  .stack{position:relative; height:100%}
  .hud{position:absolute;top:10px;left:10px;background:rgba(0,0,0,.45);padding:6px 8px;border-radius:8px;font:12px ui-monospace}
</style>
</head>
<body>
<div class="wrap">
  <aside>
    <h1>Wind-on-Wall — Invert-Blend + Stain</h1>
    <div class="row">
      <input id="file" type="file" accept="video/*">
      <button id="webcam" class="btn">Use Webcam</button>
      <button id="play" class="btn">Play/Pause</button>
    </div>
    <div class="row small">Or URL param: <span class="kbd">?src=clip.mp4</span> (same-origin or CORS-enabled)</div>

    <fieldset>
      <legend>Temporal window</legend>
      <div class="row"><label>Δt (seconds)</label><input id="dt" type="range" min="2" max="10" step="0.5" value="6"><span id="dtV">6.0</span></div>
      <div class="row"><label>Diff threshold</label><input id="thr" type="range" min="4" max="60" value="18"><span id="thrV">18</span></div>
      <div class="row"><label>Blur (px)</label><input id="blur" type="range" min="0" max="3" value="1"><span id="blurV">1</span></div>
      <div class="row"><label>Grey level</label><input id="grey" type="range" min="60" max="180" value="120"><span id="greyV">120</span></div>
      <div class="row"><label>Analysis scale</label><input id="scale" type="range" min="0.4" max="1" step="0.05" value="0.7"><span id="scaleV">0.70</span></div>
    </fieldset>

    <fieldset>
      <legend>Residual staining</legend>
      <div class="row"><label>Enable stain</label><input id="stainOn" type="checkbox" checked></div>
      <div class="row"><label>Stain decay</label><input id="decay" type="range" min="0.90" max="0.995" step="0.001" value="0.970"><span id="decayV">0.970</span></div>
      <div class="row"><label>Stain strength</label><input id="strength" type="range" min="0.1" max="1" step="0.05" value="0.50"><span id="strengthV">0.50</span></div>
      <div class="row"><label>Stain color</label><input id="color" type="color" value="#223b7a"></div>
    </fieldset>

    <fieldset>
      <legend>Export</legend>
      <div class="row">
        <button id="shot" class="btn">Save PNG</button>
        <button id="rec" class="btn">Start/Stop Rec</button>
      </div>
      <div class="row small" id="dbg">buffer: 0 | fps —</div>
    </fieldset>

    <div class="small">
      This exactly computes: <span class="kbd">0.5×Current(t) + 0.5×Invert(Past(t−Δt))</span> on a change mask, else grey.  
      Stain accumulates where the mask fires, fading by the decay factor each frame.
    </div>
  </aside>

  <main class="stack">
    <canvas id="view"></canvas>
    <canvas id="stain"></canvas>
    <div class="hud" id="hud"></div>
  </main>
</div>

<script>
(function(){
  // --- Elements & UI ---
  const view = document.getElementById('view');
  const vctx = view.getContext('2d');
  const stain = document.getElementById('stain');
  const sctx = stain.getContext('2d');

  const file = document.getElementById('file');
  const webcamBtn = document.getElementById('webcam');
  const playBtn = document.getElementById('play');
  const recBtn = document.getElementById('rec');
  const shotBtn = document.getElementById('shot');
  const hud = document.getElementById('hud');
  const dbg = document.getElementById('dbg');

  const sliders = ["dt","thr","blur","grey","scale","decay","strength"];
  const el = Object.fromEntries(sliders.map(id=>[id, document.getElementById(id)]));
  const out = Object.fromEntries(sliders.map(id=>[id+"V", document.getElementById(id+"V")]));
  const stainOn = document.getElementById('stainOn');
  const colorPick = document.getElementById('color');

  function sync(){
    out.dtV.textContent = (+el.dt.value).toFixed(1);
    out.thrV.textContent = el.thr.value;
    out.blurV.textContent = el.blur.value;
    out.greyV.textContent = el.grey.value;
    out.scaleV.textContent = (+el.scale.value).toFixed(2);
    out.decayV.textContent = (+el.decay.value).toFixed(3);
    out.strengthV.textContent = (+el.strength.value).toFixed(2);
  }
  sliders.forEach(id=>el[id].addEventListener('input', sync));
  stainOn.addEventListener('change', sync);
  colorPick.addEventListener('input', sync);
  sync();

  // --- Video source ---
  const vid = document.createElement('video');
  vid.crossOrigin = "anonymous";
  vid.playsInline = true; vid.muted = true; vid.loop = true; vid.preload = "auto";

  // load via ?src=
  const qs = new URLSearchParams(location.search);
  const src = qs.get('src'); if(src){ vid.src = src; }

  file.addEventListener('change', e=>{
    const f = e.target.files[0]; if(!f) return;
    stopWebcam();
    vid.src = URL.createObjectURL(f);
    vid.play();
  });
  playBtn.addEventListener('click', ()=> vid.paused ? vid.play() : vid.pause());

  let mediaStream = null;
  webcamBtn.addEventListener('click', async ()=>{
    try{
      mediaStream = await navigator.mediaDevices.getUserMedia({video:true, audio:false});
      vid.srcObject = mediaStream;
      vid.play();
    }catch(e){ alert('Webcam failed: '+e.message); }
  });
  function stopWebcam(){ if(mediaStream){ mediaStream.getTracks().forEach(t=>t.stop()); mediaStream=null; } }

  // --- Canvases & processing ---
  function fit(){
    const r = view.getBoundingClientRect();
    [view, stain].forEach(c=>{ c.width = Math.max(2, r.width|0); c.height = Math.max(2, r.height|0); });
  }
  new ResizeObserver(fit).observe(view);

  const proc = document.createElement('canvas');
  const pctx = proc.getContext('2d', {willReadFrequently:true});

  // ring buffer of past analysis frames
  const buf = []; const MAX_SEC = 14;
  function pushFrame(img, t){
    buf.push({t, data: new Uint8ClampedArray(img.data), w: img.width, h: img.height});
    const cutoff = t - (MAX_SEC + 2);
    while(buf.length && buf[0].t < cutoff) buf.shift();
  }
  function getPastFrame(delta){
    const target = vid.currentTime - delta;
    for(let i=buf.length-1;i>=0;i--){
      if(buf[i].t <= target) return buf[i];
    }
    return buf[0] || null;
  }

  // recording
  let recorder=null, chunks=[];
  recBtn.addEventListener('click', ()=>{
    if(recorder && recorder.state==='recording'){ recorder.stop(); return; }
    chunks = [];
    const stream = view.captureStream ? view.captureStream(30) : view.mozCaptureStream(30);
    recorder = new MediaRecorder(stream, {mimeType:'video/webm;codecs=vp9'});
    recorder.ondataavailable = e=>{ if(e.data.size) chunks.push(e.data); };
    recorder.onstop = ()=>{
      const blob = new Blob(chunks, {type:'video/webm'});
      const a = document.createElement('a');
      a.download = 'wind_on_wall_'+Date.now()+'.webm';
      a.href = URL.createObjectURL(blob);
      a.click();
    };
    recorder.start();
  });

  shotBtn.addEventListener('click', ()=>{
    // composite stain over view into a temp canvas
    const out = document.createElement('canvas');
    out.width = view.width; out.height = view.height;
    const ox = out.getContext('2d');
    ox.drawImage(view,0,0);
    ox.globalCompositeOperation='multiply';
    ox.drawImage(stain,0,0);
    const a = document.createElement('a');
    a.download = 'still_'+Date.now()+'.png';
    a.href = out.toDataURL('image/png');
    a.click();
  });

  // --- Main loop ---
  let lastT=0, fpsEMA=0;
  function tick(now){
    requestAnimationFrame(tick);
    if(vid.readyState < 2) return;

    // prepare analysis canvas
    const s = +el.scale.value;
    const aw = Math.max(160, Math.round(view.width * s));
    const ah = Math.max(90,  Math.round(view.height* s));
    if(proc.width!==aw || proc.height!==ah){ proc.width=aw; proc.height=ah; }

    // draw current frame into analysis canvas
    pctx.filter = (+el.blur.value>0) ? `blur(${el.blur.value}px)` : 'none';
    pctx.drawImage(vid, 0,0, aw, ah);
    const curr = pctx.getImageData(0,0,aw,ah);
    pushFrame(curr, vid.currentTime);

    const past = getPastFrame(+el.dt.value);
    if(!past) return;
    const c = curr.data, p = past.data;

    // build a small output + small change mask
    const small = new ImageData(aw, ah);
    const outd = small.data;
    const thr = +el.thr.value;
    const grey = +el.grey.value;

    let changedCount = 0;

    for(let i=0;i<c.length;i+=4){
      const r=c[i], g=c[i+1], b=c[i+2];
      const pr=p[i], pg=p[i+1], pb=p[i+2];

      // luminance diff
      const lc = r*0.2126 + g*0.7152 + b*0.0722;
      const lp = pr*0.2126 + pg*0.7152 + pb*0.0722;
      const d = Math.abs(lc - lp);

      if(d > thr){
        changedCount++;
        // EXACT AE-style masked invert-blend:
        outd[i]   = (r + (255 - pr)) * 0.5;
        outd[i+1] = (g + (255 - pg)) * 0.5;
        outd[i+2] = (b + (255 - pb)) * 0.5;
        outd[i+3] = 255;
      } else {
        outd[i]   = grey;
        outd[i+1] = grey;
        outd[i+2] = grey;
        outd[i+3] = 255;
      }
    }

    // render small → scale to view
    vctx.clearRect(0,0,view.width,view.height);
    // put small in temp canvas to scale
    const tmp = document.createElement('canvas');
    tmp.width = aw; tmp.height = ah;
    tmp.getContext('2d').putImageData(small, 0, 0);
    vctx.imageSmoothingEnabled = true;
    vctx.drawImage(tmp, 0, 0, view.width, view.height);

    // residual staining
    if(stainOn.checked){
      // 1) decay existing stain alpha (destination-out reduces alpha uniformly)
      const decay = +el.decay.value;
      sctx.globalCompositeOperation = 'destination-out';
      sctx.fillStyle = `rgba(0,0,0,${1-decay})`;
      sctx.fillRect(0,0,stain.width,stain.height);
      sctx.globalCompositeOperation = 'source-over';

      // 2) draw new stain where change mask fired
      //    Build a small alpha mask (white where changed)
      const maskSmall = new ImageData(aw, ah);
      const md = maskSmall.data;
      for(let i=0;i<c.length;i+=4){
        const r1=outd[i], g1=outd[i+1], b1=outd[i+2];
        // changed pixels are those not equal to grey (quick check via luminance)
        const lum = r1*0.2126 + g1*0.7152 + b1*0.0722;
        const isChanged = Math.abs(lum - grey) > 1.0; // since grey has flat luminance
        const v = isChanged ? 255 : 0;
        md[i]=md[i+1]=md[i+2]=v; md[i+3]=v;
      }
      // paint maskSmall to a temp, colorize, then stamp onto stain
      const mC = document.createElement('canvas');
      mC.width = aw; mC.height = ah;
      const mX = mC.getContext('2d');
      mX.putImageData(maskSmall,0,0);

      const col = colorPick.value;
      // scale mask up to view size on a colorizer canvas
      const colC = document.createElement('canvas');
      colC.width = view.width; colC.height = view.height;
      const colX = colC.getContext('2d');
      colX.drawImage(mC, 0,0, view.width, view.height);
      colX.globalCompositeOperation = 'source-in';
      colX.fillStyle = col;
      colX.globalAlpha = +el.strength.value; // stain intensity
      colX.fillRect(0,0,view.width, view.height);

      // Stamp onto stain
      sctx.globalCompositeOperation = 'source-over';
      sctx.drawImage(colC, 0,0);
    }

    // composite stain over view (multiply) for display
    if(stainOn.checked){
      vctx.globalCompositeOperation = 'multiply';
      vctx.drawImage(stain,0,0);
      vctx.globalCompositeOperation = 'source-over';
    }

    // HUD + debug
    const dt = now - lastT; lastT = now;
    const inst = dt>0 ? 1000/dt : 0; fpsEMA = fpsEMA? fpsEMA*0.9 + inst*0.1 : inst;
    const totalPix = aw*ah;
    const pct = 100 * (changedCount / totalPix);
    hud.textContent = `Δt = ${(+el.dt.value).toFixed(1)} s\nchanged = ${pct.toFixed(1)}% | thr=${el.thr.value}`;
    dbg.textContent = `buffer: ${buf.length} | fps ~ ${fpsEMA.toFixed(1)}`;
  }
  requestAnimationFrame(tick);

  // start playback when ready
  vid.addEventListener('loadeddata', ()=>{ vid.play().catch(()=>{}); });

})();
</script>
</body>
</html>
