<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Wind-on-Wall — Ghost Lines + Stain (Minimal)</title>
<style>
  html,body{height:100%;margin:0;background:#0b0e12;color:#e6eeff;font:14px system-ui,Segoe UI,Roboto,Helvetica,Arial}
  .wrap{display:grid;grid-template-columns:320px 1fr;gap:12px;height:100%}
  aside{padding:12px;border-right:1px solid #182133;overflow:auto}
  main{position:relative}
  canvas{position:absolute;inset:0;width:100%;height:100%;object-fit:contain;background:#000}
  h1{font-size:16px;margin:0 0 8px}
  fieldset{border:1px solid #1a2233;border-radius:10px;margin:10px 0;padding:10px}
  legend{padding:0 6px;color:#9fb7e8}
  .row{display:flex;align-items:center;gap:8px;margin:8px 0}
  .row label{flex:1;color:#8ea0ba}
  .row input[type="range"]{flex:2}
  .btn{appearance:none;border:1px solid #2a3754;background:#121826;color:#cfe1ff;border-radius:8px;padding:6px 10px;cursor:pointer}
  .hud{position:absolute;top:10px;left:10px;background:rgba(0,0,0,.45);padding:6px 8px;border-radius:8px;font:12px ui-monospace;white-space:pre}
  .kbd{font:12px ui-monospace;background:#121520;border:1px solid #1f2736;border-radius:6px;padding:1px 6px;color:#b8c7e8}
</style>
</head>
<body>
<div class="wrap">
  <aside>
    <h1>Wind-on-Wall — Live</h1>
    <div class="row">
      <input id="file" type="file" accept="video/*">
      <button id="play" class="btn">Play/Pause</button>
    </div>
    <div class="row">Or URL: <span class="kbd">?src=clip.mp4</span></div>

    <fieldset>
      <legend>Temporal</legend>
      <div class="row"><label>Δt (sec)</label><input id="dt" type="range" min="2" max="10" step="0.5" value="6"><span id="dtV">6.0</span></div>
      <div class="row"><label>Diff threshold</label><input id="thr" type="range" min="4" max="60" value="18"><span id="thrV">18</span></div>
      <div class="row"><label>Grey level</label><input id="grey" type="range" min="60" max="200" value="120"><span id="greyV">120</span></div>
    </fieldset>

    <fieldset>
      <legend>Stain</legend>
      <div class="row"><label>Enable</label><input id="stainOn" type="checkbox" checked></div>
      <div class="row"><label>Decay</label><input id="decay" type="range" min="0.90" max="0.995" step="0.001" value="0.970"><span id="decayV">0.970</span></div>
      <div class="row"><label>Strength</label><input id="strength" type="range" min="0.1" max="1" step="0.05" value="0.50"><span id="strengthV">0.50</span></div>
      <div class="row"><label>Color</label><input id="sColor" type="color" value="#223b7a"></div>
    </fieldset>

    <fieldset>
      <legend>Export</legend>
      <div class="row">
        <button id="shot" class="btn">PNG</button>
        <button id="rec" class="btn">Start/Stop Video</button>
      </div>
      <div class="row" id="dbg" style="color:#93a6c4;font-size:12px">buffer: 0 | fps —</div>
    </fieldset>
  </aside>

  <main>
    <!-- layers: ghosts (lines), stain (blotches), final composite -->
    <canvas id="ghost"></canvas>
    <canvas id="stain"></canvas>
    <canvas id="final"></canvas>
    <div id="hud" class="hud"></div>
  </main>
</div>

<script>
(function(){
  // ---- Elements ----
  const can = {
    ghost: document.getElementById('ghost'),
    stain: document.getElementById('stain'),
    final: document.getElementById('final'),
  };
  const gctx = can.ghost.getContext('2d');
  const sctx = can.stain.getContext('2d');
  const fctx = can.final.getContext('2d');

  const file = document.getElementById('file');
  const playBtn = document.getElementById('play');
  const shotBtn = document.getElementById('shot');
  const recBtn  = document.getElementById('rec');
  const hud = document.getElementById('hud');
  const dbg = document.getElementById('dbg');

  const ids = ["dt","thr","grey","decay","strength"];
  const el  = Object.fromEntries(ids.map(id=>[id, document.getElementById(id)]));
  const out = Object.fromEntries(ids.map(id=>[id+"V", document.getElementById(id+"V")]));
  const stainOn = document.getElementById('stainOn');
  const sColor  = document.getElementById('sColor');

  function sync(){
    out.dtV.textContent = (+el.dt.value).toFixed(1);
    out.thrV.textContent = el.thr.value;
    out.greyV.textContent = el.grey.value;
    out.decayV.textContent = (+el.decay.value).toFixed(3);
    out.strengthV.textContent = (+el.strength.value).toFixed(2);
  }
  [...ids.map(id=>el[id]), stainOn, sColor].forEach(x=>x.addEventListener('input', sync));
  sync();

  // ---- Video ----
  const vid = document.createElement('video');
  vid.crossOrigin="anonymous"; vid.playsInline=true; vid.muted=true; vid.loop=true; vid.preload="auto";

  const qs = new URLSearchParams(location.search);
  const src = qs.get('src'); if(src){ vid.src = src; }

  file.addEventListener('change', e=>{
    const f=e.target.files[0]; if(!f) return;
    vid.src = URL.createObjectURL(f); vid.play();
  });
  playBtn.addEventListener('click', ()=> vid.paused ? vid.play() : vid.pause());

  // ---- HiDPI sizing (ensure non-zero) ----
  function fit(){
    const dpr = Math.max(1, window.devicePixelRatio||1);
    const r = can.final.getBoundingClientRect();
    // fallback if layout not measured yet
    const W = Math.max(640, Math.round((r.width  || window.innerWidth-360)*dpr));
    const H = Math.max(360, Math.round((r.height || window.innerHeight  )*dpr));
    for(const k in can){ can[k].width=W; can[k].height=H; }
    proc.width=W; proc.height=H;
    maskCanvas.width=W; maskCanvas.height=H;
    colCanvas.width=W; colCanvas.height=H;
  }
  window.addEventListener('load', fit);
  new ResizeObserver(fit).observe(can.final);

  // ---- Offscreens ----
  const proc = document.createElement('canvas');
  const pctx = proc.getContext('2d', {willReadFrequently:true});
  const maskCanvas = document.createElement('canvas');
  const maskCtx = maskCanvas.getContext('2d');
  const colCanvas = document.createElement('canvas');
  const colCtx = colCanvas.getContext('2d');

  // Ring buffer of full-res frames
  const buf=[]; const MAX_SEC=14;
  function pushFrame(img,t){ buf.push({t, data:new Uint8ClampedArray(img.data), w:img.width, h:img.height});
    const cutoff=t-(MAX_SEC+2); while(buf.length && buf[0].t<cutoff) buf.shift();
  }
  function getPast(delta){
    const target = vid.currentTime - delta;
    for(let i=buf.length-1;i>=0;i--){ if(buf[i].t <= target) return buf[i]; }
    return null;
  }

  function drawContained(ctx, video, W, H){
    ctx.clearRect(0,0,W,H);
    const vw=video.videoWidth||0, vh=video.videoHeight||0;
    if(vw && vh){
      const s = Math.min(W/vw, H/vh);
      const dw=(vw*s)|0, dh=(vh*s)|0;
      const dx=((W-dw)/2)|0, dy=((H-dh)/2)|0;
      ctx.drawImage(video, dx,dy,dw,dh);
    }
  }

  function hexRGB(hex){const m=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return m?[parseInt(m[1],16),parseInt(m[2],16),parseInt(m[3],16)]:[255,255,255];}

  // ---- Export ----
  let recorder=null, chunks=[];
  recBtn.addEventListener('click', ()=>{
    if(recorder && recorder.state==='recording'){ recorder.stop(); return; }
    chunks=[];
    const stream = can.final.captureStream ? can.final.captureStream(30) : can.final.mozCaptureStream(30);
    recorder=new MediaRecorder(stream,{mimeType:'video/webm;codecs=vp9'});
    recorder.ondataavailable=e=>{ if(e.data.size) chunks.push(e.data); };
    recorder.onstop=()=>{
      const blob=new Blob(chunks,{type:'video/webm'});
      const a=document.createElement('a'); a.download='wind_on_wall_'+Date.now()+'.webm';
      a.href=URL.createObjectURL(blob); a.click();
    };
    recorder.start();
  });
  document.getElementById('shot').addEventListener('click', ()=>{
    const a=document.createElement('a'); a.download='still_'+Date.now()+'.png';
    a.href=can.final.toDataURL('image/png'); a.click();
  });

  // ---- Main loop ----
  let lastT=0,fpsEMA=0;
  function tick(now){
    requestAnimationFrame(tick);
    if(vid.readyState<2) return;

    const W = can.final.width, H = can.final.height;

    // draw current frame → analysis buffer
    drawContained(pctx, vid, W, H);
    const curr = pctx.getImageData(0,0,W,H);
    pushFrame(curr, vid.currentTime);

    const past = getPast(+el.dt.value);
    // If not enough history yet: draw plain grey (no “mystery black”)
    if(!past){
      fctx.fillStyle = `rgb(${el.grey.value},${el.grey.value},${el.grey.value})`;
      fctx.fillRect(0,0,W,H);
      hud.textContent = `Δt = ${(+el.dt.value).toFixed(1)} s\nwarming up…`;
      return;
    }

    const c=curr.data, p=past.data;
    const thr=+el.thr.value, grey=+el.grey.value;
    const [sr,sg,sb] = hexRGB(sColor.value);

    // 1) CHANGE MASK (by luminance diff)
    const mask = new Uint8ClampedArray(W*H);
    let changed=0;
    for(let i=0,j=0;i<c.length;i+=4,j++){
      const lc = c[i]*0.2126 + c[i+1]*0.7152 + c[i+2]*0.0722;
      const lp = p[i]*0.2126 + p[i+1]*0.7152 + p[i+2]*0.0722;
      if(Math.abs(lc - lp) > thr){ mask[j]=255; changed++; }
      else { mask[j]=0; }
    }

    // 2) GHOST LINES = Sobel edges on mask (gives thin lines)
    const edge = new Uint8ClampedArray(W*H);
    for(let y=1;y<H-1;y++){
      for(let x=1;x<W-1;x++){
        const j=y*W+x;
        const a=mask[j-W-1], b=mask[j-W], c1=mask[j-W+1];
        const d1=mask[j-1],   f=mask[j+1];
        const g1=mask[j+W-1], h=mask[j+W], i1=mask[j+W+1];
        const Gx = -a -2*d1 - g1 + c1 + 2*f + i1;
        const Gy = -a -2*b - c1 + g1 + 2*h + i1;
        const mag = Math.sqrt(Gx*Gx + Gy*Gy);
        edge[j] = mag>128 ? Math.min(255, mag/1.5) : 0; // single, fixed gain
      }
    }

    // 3) BUILD FINAL IMAGE (grey base + ghost lines; per-pixel)
    const out = fctx.createImageData(W,H);
    const od = out.data;
    for(let i=0,j=0;i<c.length;i+=4,j++){
      // Base = grey
      let R=grey, G=grey, B=grey;

      const a = edge[j]/255; // 0..1 ghost alpha at edges
      if(a>0){
        // AE-style ghost color at this pixel
        const gR = (c[i]   + (255 - p[i]))   * 0.5;
        const gG = (c[i+1] + (255 - p[i+1])) * 0.5;
        const gB = (c[i+2] + (255 - p[i+2])) * 0.5;
        // simple over grey with alpha a
        R = R*(1-a) + gR*a;
        G = G*(1-a) + gG*a;
        B = B*(1-a) + gB*a;
      }

      od[i]=R; od[i+1]=G; od[i+2]=B; od[i+3]=255;
    }
    fctx.putImageData(out,0,0);

    // 4) STAIN (solid blotches): accumulate full mask
    if(stainOn.checked){
      // decay existing stain
      const decay=+el.decay.value;
      sctx.globalCompositeOperation='destination-out';
      sctx.fillStyle = `rgba(0,0,0,${1-decay})`;
      sctx.fillRect(0,0,W,H);
      sctx.globalCompositeOperation='source-over';

      // draw mask → colorize → add with strength
      const mImg = maskCtx.createImageData(W,H);
      const mdat = mImg.data;
      for(let j=0,k=0;j<mask.length;j++,k+=4){
        const v=mask[j];
        mdat[k]=mdat[k+1]=mdat[k+2]=v; mdat[k+3]=v;
      }
      maskCtx.putImageData(mImg,0,0);

      colCtx.clearRect(0,0,W,H);
      colCtx.drawImage(maskCanvas,0,0);
      colCtx.globalCompositeOperation='source-in';
      colCtx.fillStyle = `rgb(${sr},${sg},${sb})`;
      colCtx.globalAlpha = +el.strength.value;
      colCtx.fillRect(0,0,W,H);
      colCtx.globalAlpha=1; colCtx.globalCompositeOperation='source-over';

      sctx.drawImage(colCanvas,0,0);

      // multiply stain on top of final
      fctx.globalCompositeOperation='multiply';
      fctx.drawImage(can.stain,0,0);
      fctx.globalCompositeOperation='source-over';
    }

    // HUD / debug
    const dt = now - lastT; lastT = now;
    const inst = dt>0 ? 1000/dt : 0; fpsEMA = fpsEMA? fpsEMA*0.9 + inst*0.1 : inst;
    const pct = 100*(changed/(W*H));
    hud.textContent = `Δt=${(+el.dt.value).toFixed(1)}s  thr=${el.thr.value}  grey=${el.grey.value}\nchanged≈${pct.toFixed(1)}%`;
    dbg.textContent = `buffer: ${buf.length} | fps ~ ${fpsEMA.toFixed(1)}`;
  }
  requestAnimationFrame(tick);

  vid.addEventListener('loadeddata', ()=>{ vid.play().catch(()=>{}); });
})();
</script>
</body>
</html>
