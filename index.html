<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Wind-on-Wall — Live</title>
<style>
  :root{--bg:#0b0e12;--fg:#e6eeff;--mut:#90a1bb}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font:14px/1.35 system-ui,Segoe UI,Roboto,Helvetica,Arial}
  .wrap{display:grid;grid-template-columns:380px 1fr;gap:14px;height:100%}
  aside{padding:14px 12px 16px;border-right:1px solid #1a2233;overflow:auto}
  main{position:relative}
  canvas{position:absolute;inset:0;width:100%;height:100%;object-fit:contain;background:#000}
  h1{font-size:16px;margin:0 0 10px}
  fieldset{border:1px solid #1a2233;border-radius:10px;margin:10px 0;padding:10px}
  legend{padding:0 6px;color:#9fb7e8}
  .row{display:flex;align-items:center;gap:8px;margin:8px 0;flex-wrap:wrap}
  .row label{flex:1;color:var(--mut)}
  .row input[type="range"], .row select{flex:2}
  .btn{appearance:none;border:1px solid #2a3754;background:#121826;color:#cfe1ff;border-radius:8px;padding:6px 10px;cursor:pointer}
  .btn.secondary{background:#0e1422;border-color:#1f2b44;color:#a8b7d6}
  .btn:disabled{opacity:.5;cursor:not-allowed}
  .kbd{font:12px ui-monospace;background:#121520;border:1px solid #1f2736;border-radius:6px;padding:1px 6px;color:#b8c7e8}
  .small{font-size:12px;color:#93a6c4}
  .hud{position:absolute;top:10px;left:10px;background:rgba(0,0,0,.45);padding:6px 8px;border-radius:8px;font:12px ui-monospace;white-space:pre}
  .rec{position:absolute;top:10px;right:10px;background:rgba(0,0,0,.55);padding:6px 10px;border-radius:999px;font:12px ui-monospace;display:flex;align-items:center;gap:8px}
  .dot{width:8px;height:8px;background:#ff5b5b;border-radius:50%;box-shadow:0 0 8px #ff5b5b}
  .nosrc{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;color:#aac;font:12px ui-monospace;pointer-events:none}
</style>
</head>
<body>
<div class="wrap">
  <aside>
    <h1>Wind-on-Wall — Live</h1>
    <div class="row">
      <input id="file" type="file" accept="video/*">
      <button id="webcam" class="btn">Webcam</button>
      <button id="play" class="btn secondary">Play/Pause</button>
    </div>
    <div class="row small">Or URL: <span class="kbd">?src=clip.mp4</span> (same-origin or CORS)</div>

    <fieldset>
      <legend>Temporal window</legend>
      <div class="row"><label>Δt (seconds)</label><input id="dt" type="range" min="2" max="10" step="0.5" value="6"><span id="dtV">6.0</span></div>
      <div class="row"><label>Diff threshold</label><input id="thr" type="range" min="4" max="60" value="18"><span id="thrV">18</span></div>
      <div class="row"><label>Grey level</label><input id="grey" type="range" min="60" max="200" value="120"><span id="greyV">120</span></div>
      <div class="row"><label>Pre-blur (px)</label><input id="preblur" type="range" min="0" max="3" value="0"><span id="preblurV">0</span></div>
    </fieldset>

    <fieldset>
      <legend>Ghosts (motion)</legend>
      <div class="row"><label>Ghost opacity</label><input id="gAlpha" type="range" min="0" max="1" step="0.05" value="0.7"><span id="gAlphaV">0.70</span></div>
      <div class="row"><label>Blend mode</label>
        <select id="gBlend">
          <option value="normal">Normal</option>
          <option value="screen" selected>Screen</option>
          <option value="lighter">Lighter (Add)</option>
          <option value="multiply">Multiply</option>
          <option value="difference">Difference</option>
        </select>
      </div>
      <div class="row">
        <label>Use custom color</label>
        <input id="gUseColor" type="checkbox">
        <input id="gColor" type="color" value="#ffffff">
      </div>
    </fieldset>

    <fieldset>
      <legend>Stain (residual blotches)</legend>
      <div class="row"><label>Enable stain</label><input id="stainOn" type="checkbox" checked></div>
      <div class="row"><label>Decay</label><input id="decay" type="range" min="0.90" max="0.995" step="0.001" value="0.970"><span id="decayV">0.970</span></div>
      <div class="row"><label>Strength</label><input id="strength" type="range" min="0.1" max="1" step="0.05" value="0.50"><span id="strengthV">0.50</span></div>
      <div class="row"><label>Expand (px)</label><input id="expand" type="range" min="0" max="8" step="1" value="2"><span id="expandV">2</span></div>
      <div class="row"><label>Stain color</label><input id="sColor" type="color" value="#223b7a"></div>
    </fieldset>

    <fieldset>
      <legend>Export</legend>
      <div class="row">
        <label>Format</label>
        <select id="format">
          <option value="mp4">MP4 (preferred)</option>
          <option value="webm">WebM</option>
          <option value="auto" selected>Auto (best available)</option>
        </select>
      </div>
      <div class="row">
        <button id="recStart" class="btn">Start Recording</button>
        <button id="recStop" class="btn" disabled>Stop & Save</button>
      </div>
      <div class="row">
        <button id="shot" class="btn secondary">Export PNG</button>
      </div>
      <div class="row">
        <button id="exportOne" class="btn">Export 1:1 (source)</button>
        <label style="flex:none;">Match preview look</label>
        <input id="matchPreview" type="checkbox" checked>
      </div>
      <div class="row small" id="supportNote"></div>
      <div class="row small" id="dbg">buffer: 0 | fps —</div>
    </fieldset>
  </aside>

  <main>
    <canvas id="stain"></canvas>
    <canvas id="ghost"></canvas>
    <canvas id="final"></canvas>
    <div id="hud" class="hud"></div>
    <div id="recHUD" class="rec" style="display:none;"><span class="dot"></span><span id="recTime">REC 00:00</span></div>
    <div id="nosrc" class="nosrc" style="display:none;">load a clip or use the webcam</div>
  </main>
</div>

<script>
(function(){
  // ---------- Elements ----------
  const can = { stain: $('#stain'), ghost: $('#ghost'), final: $('#final') };
  const sctx = can.stain.getContext('2d');
  const gctx = can.ghost.getContext('2d');
  const fctx = can.final.getContext('2d');

  const file = $('#file'), webcamBtn=$('#webcam'), playBtn=$('#play');
  const recStartBtn=$('#recStart'), recStopBtn=$('#recStop'), shotBtn=$('#shot');
  const exportOneBtn=$('#exportOne'), matchPreview=$('#matchPreview');
  const hud=$('#hud'), recHUD=$('#recHUD'), recTime=$('#recTime');
  const dbg=$('#dbg'), supportNote=$('#supportNote'), nosrc=$('#nosrc');

  const ids = ["dt","thr","grey","preblur","gAlpha","decay","strength","expand"];
  const el  = Object.fromEntries(ids.map(id=>[id, $('#'+id)]));
  const out = Object.fromEntries(ids.map(id=>[id+'V', $('#'+id+'V')]));
  const stainOn=$('#stainOn'), sColor=$('#sColor'), gBlend=$('#gBlend'), formatSel=$('#format');
  const gUseColor=$('#gUseColor'), gColor=$('#gColor');

  function $(id){ return document.getElementById(id); }
  function sync(){
    out.dtV.textContent=(+el.dt.value).toFixed(1);
    out.thrV.textContent=el.thr.value;
    out.greyV.textContent=el.grey.value;
    out.preblurV.textContent=el.preblur.value;
    out.gAlphaV.textContent=(+el.gAlpha.value).toFixed(2);
    out.decayV.textContent=(+el.decay.value).toFixed(3);
    out.strengthV.textContent=(+el.strength.value).toFixed(2);
    out.expandV.textContent=el.expand.value;
  }
  [...ids.map(k=>el[k]), stainOn, sColor, gBlend, formatSel, gUseColor, gColor].forEach(x=>x.addEventListener('input', sync));
  sync();

  // ---------- Source ----------
  const vid = document.createElement('video');
  vid.crossOrigin="anonymous"; vid.playsInline=true; vid.muted=true; vid.loop=true; vid.preload="auto";

  const qs = new URLSearchParams(location.search); const src=qs.get('src'); if(src){ vid.src=src; }

  let mediaStream=null;
  file.addEventListener('change', e=>{
    const f=e.target.files[0]; if(!f) return;
    stopWebcam(); resetState(); vid.src=URL.createObjectURL(f); vid.play();
  });
  playBtn.addEventListener('click', ()=> vid.paused ? vid.play() : vid.pause());
  webcamBtn.addEventListener('click', ()=> startWebcam().catch(e=>alert('Webcam failed: '+e.message)));
  async function startWebcam(){ stopWebcam(); resetState(); mediaStream=await navigator.mediaDevices.getUserMedia({video:true,audio:false}); vid.srcObject=mediaStream; await vid.play(); }
  function stopWebcam(){ if(mediaStream){ mediaStream.getTracks().forEach(t=>t.stop()); mediaStream=null; } }

  // ---------- Sizing ----------
  const proc=document.createElement('canvas'), pctx=proc.getContext('2d',{willReadFrequently:true});
  const maskCanvas=document.createElement('canvas'), maskCtx=maskCanvas.getContext('2d');
  const colCanvas=document.createElement('canvas'), colCtx=colCanvas.getContext('2d');

  function fit(){
    const dpr=Math.max(1,window.devicePixelRatio||1);
    const r=can.final.getBoundingClientRect();
    const W=Math.max(2,Math.round(r.width*dpr)), H=Math.max(2,Math.round(r.height*dpr));
    [can.stain, can.ghost, can.final, proc, maskCanvas, colCanvas].forEach(c=>{ c.width=W; c.height=H; });
  }
  new ResizeObserver(fit).observe(can.final); fit();

  // ---------- Buffers ----------
  const buf=[]; const MAX_SEC=14;
  function pushFrame(img,t){ buf.push({t, data:new Uint8ClampedArray(img.data), w:img.width, h:img.height}); const cutoff=t-(MAX_SEC+2); while(buf.length && buf[0].t<cutoff) buf.shift(); }
  function getPastFrame(delta){ const target=vid.currentTime-delta; for(let i=buf.length-1;i>=0;i--){ if(buf[i].t<=target) return buf[i]; } return buf[0]||null; }

  function drawVideoContained(ctx, video, W, H, blurPx){
    ctx.save(); ctx.clearRect(0,0,W,H); if(blurPx>0) ctx.filter=`blur(${blurPx}px)`;
    const vw=video.videoWidth||0, vh=video.videoHeight||0;
    if(vw&&vh){ const s=Math.min(W/vw,H/vh), dw=Math.round(vw*s), dh=Math.round(vh*s), dx=Math.floor((W-dw)/2), dy=Math.floor((H-dh)/2); ctx.drawImage(video,dx,dy,dw,dh); }
    ctx.restore();
  }

  // ---------- Live recording ----------
  let recorder=null, chunks=[], recStartTime=0, recTimer=null, recMime="", recExt="webm";
  function bestSupported(){
    const mp4='video/mp4;codecs=avc1.42E01E,mp4a.40.2', webm='video/webm;codecs=vp9,opus', webm2='video/webm;codecs=vp8,opus';
    const canMp4=!!(window.MediaRecorder&&MediaRecorder.isTypeSupported&&MediaRecorder.isTypeSupported(mp4));
    const canWebm=!!(window.MediaRecorder&&MediaRecorder.isTypeSupported&&(MediaRecorder.isTypeSupported(webm)||MediaRecorder.isTypeSupported(webm2)));
    return {canMp4,canWebm,mp4,webm:(MediaRecorder.isTypeSupported&&MediaRecorder.isTypeSupported(webm)?webm:webm2)};
  }
  function refreshSupportNote(){
    const s=bestSupported(), fmt=formatSel.value;
    supportNote.innerHTML = fmt==='mp4' ? (s.canMp4?'<span class="ok">MP4 recording supported ✓</span>':'<span class="warn">MP4 not supported. Use Safari/WebKit or switch to WebM.</span>')
                           : fmt==='webm'? (s.canWebm?'WebM recording supported ✓':'<span class="warn">WebM not supported.</span>')
                           : (s.canMp4?'Auto → MP4':(s.canWebm?'Auto → WebM':'<span class="warn">Recording unsupported.</span>'));
  }
  refreshSupportNote(); formatSel.addEventListener('change', refreshSupportNote);

  recStartBtn.addEventListener('click', startRecording);
  recStopBtn .addEventListener('click', stopRecording);
  function startRecording(){
    const s=bestSupported(), sel=formatSel.value;
    let mime=''; if(sel==='mp4') mime=s.canMp4?s.mp4:''; else if(sel==='webm') mime=s.canWebm?s.webm:''; else mime=s.canMp4?s.mp4:(s.canWebm?s.webm:'');
    if(!mime){ alert('Recording format not supported on this browser.'); return; }
    const stream=can.final.captureStream?can.final.captureStream(30):can.final.mozCaptureStream(30);
    chunks=[]; recorder=new MediaRecorder(stream,{mimeType:mime,videoBitsPerSecond:8_000_000}); recMime=mime; recExt=mime.startsWith('video/mp4')?'mp4':'webm';
    recorder.ondataavailable=e=>{ if(e.data&&e.data.size) chunks.push(e.data); };
    recorder.onstop=()=>{ const blob=new Blob(chunks,{type:recMime}); const a=document.createElement('a'); a.download=`wind_on_wall_${Date.now()}.${recExt}`; a.href=URL.createObjectURL(blob); a.click(); stopRecUI(); };
    recorder.start(250);
    recStartTime=performance.now(); recTimer=setInterval(()=>{ const t=Math.floor((performance.now()-recStartTime)/1000); const mm=String(Math.floor(t/60)).padStart(2,'0'); const ss=String(t%60).padStart(2,'0'); recTime.textContent=`REC ${mm}:${ss}`; },250);
    recHUD.style.display='flex'; recStartBtn.disabled=true; recStopBtn.disabled=false;
  }
  function stopRecording(){ if(recorder && recorder.state==='recording') recorder.stop(); }
  function stopRecUI(){ clearInterval(recTimer); recTimer=null; recHUD.style.display='none'; recStartBtn.disabled=false; recStopBtn.disabled=true; }
  shotBtn.addEventListener('click', ()=>{ const a=document.createElement('a'); a.download='still_'+Date.now()+'.png'; a.href=can.final.toDataURL('image/png'); a.click(); });

  // ---------- Helpers ----------
  function hexToRgb(hex){ const m=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex); return m?[parseInt(m[1],16),parseInt(m[2],16),parseInt(m[3],16)]:[255,255,255]; }

  // ---------- Live loop (unchanged visuals) ----------
  let lastT=0, fpsEMA=0, suspendLive=false;
  requestAnimationFrame(function tick(now){
    requestAnimationFrame(tick);
    if(suspendLive) return;

    const W=can.final.width, H=can.final.height;
    const grey=+el.grey.value; fctx.clearRect(0,0,W,H); fctx.fillStyle=`rgb(${grey},${grey},${grey})`; fctx.fillRect(0,0,W,H);

    if(vid.readyState<2){ nosrc.style.display='block'; return; } else { nosrc.style.display='none'; }

    drawVideoContained(pctx, vid, W, H, +el.preblur.value);
    const curr=pctx.getImageData(0,0,W,H); pushFrame(curr, vid.currentTime);
    const past=getPastFrame(+el.dt.value); if(!past) return;

    const c=curr.data, p=past.data, ghostImg=gctx.createImageData(W,H), gd=ghostImg.data, thr=+el.thr.value;
    const mask=new Uint8ClampedArray(W*H); let changedCount=0;

    for(let i=0,j=0;i<c.length;i+=4,j++){
      const r=c[i], g=c[i+1], b=c[i+2], pr=p[i], pg=p[i+1], pb=p[i+2];
      const lc=r*.2126+g*.7152+b*.0722, lp=pr*.2126+pg*.7152+pb*.0722, d=Math.abs(lc-lp);
      if(d>thr){ changedCount++; mask[j]=255;
        if(gUseColor.checked){ const [cr,cg,cb]=hexToRgb(gColor.value); const a=Math.max(40,Math.min(255,(d-thr)*8)); gd[i]=cr; gd[i+1]=cg; gd[i+2]=cb; gd[i+3]=a; }
        else { gd[i]=(r+(255-pr))*0.5; gd[i+1]=(g+(255-pg))*0.5; gd[i+2]=(b+(255-pb))*0.5; gd[i+3]=255; }
      } else { gd[i]=gd[i+1]=gd[i+2]=0; gd[i+3]=0; }
    }
    gctx.putImageData(ghostImg,0,0);

    if(stainOn.checked){
      const decay=+el.decay.value; sctx.globalCompositeOperation='destination-out'; sctx.fillStyle=`rgba(0,0,0,${1-decay})`; sctx.fillRect(0,0,W,H); sctx.globalCompositeOperation='source-over';
      const mImg=maskCtx.createImageData(W,H), mdat=mImg.data;
      for(let j=0,k=0;j<mask.length;j++,k+=4){ const v=mask[j]; mdat[k]=mdat[k+1]=mdat[k+2]=v; mdat[k+3]=v; }
      maskCtx.putImageData(mImg,0,0);
      colCtx.clearRect(0,0,W,H); const expand=+el.expand.value; if(expand>0) colCtx.filter=`blur(${expand}px)`; colCtx.drawImage(maskCanvas,0,0); colCtx.filter='none';
      colCtx.globalCompositeOperation='source-in'; colCtx.fillStyle=sColor.value; colCtx.globalAlpha=+el.strength.value; colCtx.fillRect(0,0,W,H); colCtx.globalCompositeOperation='source-over'; colCtx.globalAlpha=1;
      sctx.drawImage(colCanvas,0,0);
    }

    if(stainOn.checked){ fctx.globalCompositeOperation='multiply'; fctx.drawImage(can.stain,0,0); fctx.globalCompositeOperation='source-over'; }
    fctx.globalAlpha=+el.gAlpha.value; fctx.globalCompositeOperation=gBlend.value; fctx.drawImage(can.ghost,0,0); fctx.globalAlpha=1; fctx.globalCompositeOperation='source-over';

    const dt=now-lastT; lastT=now; const inst=dt>0?1000/dt:0; fpsEMA=fpsEMA?fpsEMA*0.9+inst*0.1:inst;
    const pct=100*(changedCount/(W*H));
    hud.textContent=`Δt = ${(+el.dt.value).toFixed(1)} s
thr = ${el.thr.value}, pre-blur = ${el.preblur.value}, grey = ${el.grey.value}
ghost: ${gBlend.value}, α=${(+el.gAlpha.value).toFixed(2)}${gUseColor.checked?`, color=${gColor.value}`:''}
stain: decay=${(+el.decay.value).toFixed(3)}, expand=${el.expand.value}, strength=${(+el.strength.value).toFixed(2)}
changed = ${pct.toFixed(1)}%`;
    const s=bestSupported(); dbg.textContent=`buffer: ${buf.length} | fps ~ ${fpsEMA.toFixed(1)} | support: ${s.canMp4?'MP4✓':'MP4×'}/${s.canWebm?'WebM✓':'WebM×'}`;
  });
  vid.addEventListener('loadeddata', ()=>{ vid.play().catch(()=>{}); });

  // ---------- Export 1:1 (source) — robust, no extra UI ----------
  exportOneBtn.addEventListener('click', exportSourceOnce);

  let exporting=false, vfcId=null, rafId=null, watchId=null, endHandler=null, restoreSizes=null;
  let expRecorder=null, expChunks=[], expRecMime='', expRecExt='webm', expDone=null, prevState=null;

  async function exportSourceOnce(){
    if(vid.srcObject){ alert('1:1 export is for file/URL clips, not webcam.'); return; }
    if(!(vid.currentSrc || vid.src)){ alert('Load a clip first.'); return; }
    if(vid.readyState<1){ await once(vid,'loadedmetadata'); }
    const vw=vid.videoWidth|0, vh=vid.videoHeight|0; if(!vw||!vh){ alert('Video metadata unavailable.'); return; }

    const {mime,ext}=pickMime(); if(!mime){ alert('Export not supported here. Try Safari (MP4) or Chrome/Firefox (WebM).'); return; }

    exportOneBtn.disabled=true; recStartBtn.disabled=true;
    suspendLive=true; exporting=true;

    // recorder on source-sized offscreen canvas
    const outCanvas=document.createElement('canvas'); outCanvas.width=vw; outCanvas.height=vh;
    const octx=outCanvas.getContext('2d');
    expChunks=[];
    const stream=outCanvas.captureStream?outCanvas.captureStream(30):outCanvas.mozCaptureStream(30);
    expRecorder=new MediaRecorder(stream,{mimeType:mime,videoBitsPerSecond:8_000_000});
    expRecMime=mime; expRecExt=ext;
    expDone=new Promise(resolve=>{ expRecorder.ondataavailable=e=>{ if(e.data&&e.data.size) expChunks.push(e.data); }; expRecorder.onstop=()=>resolve(); });
    expRecorder.start(250);

    // snapshot + prep
    prevState={loop:vid.loop,t:vid.currentTime,paused:vid.paused};
    resetState(); vid.pause(); vid.loop=false; try{ vid.currentTime=0; }catch(_){}
    const saved = snapshotSizes(); restoreSizes = ()=> applySizes(saved);
    if(!matchPreview.checked) resizePipeline(vw,vh); // native-analysis path

    function drawContain(srcCanvas, dstCtx, dstW, dstH){
      const sw=srcCanvas.width, sh=srcCanvas.height; const s=Math.min(dstW/sw,dstH/sh);
      const dw=Math.round(sw*s), dh=Math.round(sh*s), dx=Math.floor((dstW-dw)/2), dy=Math.floor((dstH-dh)/2);
      dstCtx.clearRect(0,0,dstW,dstH); dstCtx.drawImage(srcCanvas,dx,dy,dw,dh);
    }

    function processOneFrame(W,H){
      const grey=+el.grey.value; fctx.clearRect(0,0,W,H); fctx.fillStyle=`rgb(${grey},${grey},${grey})`; fctx.fillRect(0,0,W,H);

      drawVideoContained(pctx, vid, W, H, +el.preblur.value);
      const curr=pctx.getImageData(0,0,W,H); pushFrame(curr, vid.currentTime);

      const past=getPastFrame(+el.dt.value);
      if(past){
        const c=curr.data,p=past.data,ghostImg=gctx.createImageData(W,H),gd=ghostImg.data,thr=+el.thr.value,mask=new Uint8ClampedArray(W*H);
        for(let i=0,j=0;i<c.length;i+=4,j++){
          const r=c[i],g=c[i+1],b=c[i+2], pr=p[i],pg=p[i+1],pb=p[i+2];
          const lc=r*.2126+g*.7152+b*.0722, lp=pr*.2126+pg*.7152+pb*.0722, d=Math.abs(lc-lp);
          if(d>thr){
            mask[j]=255;
            if(gUseColor.checked){ const [cr,cg,cb]=hexToRgb(gColor.value); const a=Math.max(40,Math.min(255,(d-thr)*8)); gd[i]=cr;gd[i+1]=cg;gd[i+2]=cb;gd[i+3]=a; }
            else { gd[i]=(r+(255-pr))*0.5; gd[i+1]=(g+(255-pg))*0.5; gd[i+2]=(b+(255-pb))*0.5; gd[i+3]=255; }
          } else { gd[i]=gd[i+1]=gd[i+2]=0; gd[i+3]=0; }
        }
        gctx.putImageData(ghostImg,0,0);

        if(stainOn.checked){
          const decay=+el.decay.value; sctx.globalCompositeOperation='destination-out'; sctx.fillStyle=`rgba(0,0,0,${1-decay})`; sctx.fillRect(0,0,W,H); sctx.globalCompositeOperation='source-over';
          const mImg=maskCtx.createImageData(W,H), mdat=mImg.data;
          for(let j=0,k=0;j<mask.length;j++,k+=4){ const v=mask[j]; mdat[k]=mdat[k+1]=mdat[k+2]=v; mdat[k+3]=v; }
          maskCtx.putImageData(mImg,0,0);
          colCtx.clearRect(0,0,W,H); const expand=+el.expand.value; if(expand>0) colCtx.filter=`blur(${expand}px)`; colCtx.drawImage(maskCanvas,0,0); colCtx.filter='none';
          colCtx.globalCompositeOperation='source-in'; colCtx.fillStyle=sColor.value; colCtx.globalAlpha=+el.strength.value; colCtx.fillRect(0,0,W,H); colCtx.globalCompositeOperation='source-over'; colCtx.globalAlpha=1;
          sctx.drawImage(colCanvas,0,0);
        }
      }

      if(stainOn.checked){ fctx.globalCompositeOperation='multiply'; fctx.drawImage(can.stain,0,0); fctx.globalCompositeOperation='source-over'; }
      fctx.globalAlpha=+el.gAlpha.value; fctx.globalCompositeOperation=gBlend.value; fctx.drawImage(can.ghost,0,0); fctx.globalAlpha=1; fctx.globalCompositeOperation='source-over';
    }

    function stepAndBlit(){
      const W=can.final.width, H=can.final.height;
      processOneFrame(W,H);
      if(matchPreview.checked) drawContain(can.final, octx, vw, vh);
      else { octx.clearRect(0,0,vw,vh); octx.drawImage(can.final,0,0,vw,vh); }
    }

    // robust finish: ended OR time >= duration-ε OR stall 5s OR wallclock > duration+12s
    const D = vid.duration, eps=0.035;
    let lastCT=-1, stalledMs=0, startWall=performance.now();
    endHandler=()=> finalize(false,vw,vh);
    vid.addEventListener('ended', endHandler, {once:true});
    watchId=setInterval(()=>{
      const ct=vid.currentTime;
      const wall=performance.now()-startWall;
      if(isFinite(D) && D>0 && ct >= D-eps) finalize(false,vw,vh);
      else if(Math.abs(ct-lastCT)<1e-4 && !vid.paused){ stalledMs+=500; if(stalledMs>5000) finalize(false,vw,vh); }
      else { stalledMs=0; lastCT=ct; }
      if(isFinite(D) && wall > (D*1000 + 12000)) finalize(false,vw,vh);
    }, 500);

    const hasVFC = typeof vid.requestVideoFrameCallback === 'function';
    function driveVFC(){ if(!exporting) return; stepAndBlit(); vfcId=vid.requestVideoFrameCallback(()=>driveVFC()); }
    function driveRAF(){ if(!exporting) return; stepAndBlit(); rafId=requestAnimationFrame(driveRAF); }

    try{ await vid.play(); if(hasVFC) vfcId=vid.requestVideoFrameCallback(()=>driveVFC()); else rafId=requestAnimationFrame(driveRAF); }
    catch(e){ console.error(e); finalize(true,vw,vh); }

    async function finalize(cancelled,vw,vh){
      if(!exporting) return; exporting=false;
      if(vfcId && vid.cancelVideoFrameCallback){ try{ vid.cancelVideoFrameCallback(vfcId); }catch(_){} }
      if(rafId){ try{ cancelAnimationFrame(rafId); }catch(_){} } vfcId=null; rafId=null;
      if(watchId){ clearInterval(watchId); watchId=null; }
      if(endHandler){ try{ vid.removeEventListener('ended', endHandler); }catch(_){} endHandler=null; }

      try{ if(expRecorder && expRecorder.state==='recording') expRecorder.stop(); }catch(_){} await 0;
      try{ await expDone; }catch(_){}
      if(!cancelled && expChunks.length){
        const blob=new Blob(expChunks,{type:expRecMime});
        const a=document.createElement('a');
        const tag=matchPreview.checked?'match':'native';
        a.download=`wind_on_wall_1x_${vw}x${vh}_${tag}_${Date.now()}.${expRecExt}`;
        a.href=URL.createObjectURL(blob); a.click();
      }
      if(restoreSizes && !matchPreview.checked) restoreSizes();

      vid.loop=prevState.loop; try{ vid.currentTime=prevState.t; }catch(_){}
      if(!prevState.paused){ try{ await vid.play(); }catch(_){ } }

      suspendLive=false; exportOneBtn.disabled=false; recStartBtn.disabled=false;
    }
  }

  // ---------- Utilities ----------
  function once(el,ev){ return new Promise(res=>el.addEventListener(ev,res,{once:true})); }
  function pickMime(){
    const s=bestSupported(), sel=formatSel.value; let mime='';
    if(sel==='mp4') mime=s.canMp4?s.mp4:''; else if(sel==='webm') mime=s.canWebm?s.webm:''; else mime=s.canMp4?s.mp4:(s.canWebm?s.webm:'');
    return {mime,ext:mime.startsWith('video/mp4')?'mp4':'webm'};
  }
  function resetState(){ buf.length=0; sctx.clearRect(0,0,can.stain.width,can.stain.height); gctx.clearRect(0,0,can.ghost.width,can.ghost.height); }
  function snapshotSizes(){ return {W:can.final.width,H:can.final.height,sW:can.stain.width,sH:can.stain.height,gW:can.ghost.width,gH:can.ghost.height,pW:proc.width,pH:proc.height,mW:maskCanvas.width,mH:maskCanvas.height,cW:colCanvas.width,cH:colCanvas.height}; }
  function applySizes(s){ can.final.width=s.W; can.final.height=s.H; can.stain.width=s.sW; can.stain.height=s.sH; can.ghost.width=s.gW; can.ghost.height=s.gH; proc.width=s.pW; proc.height=s.pH; maskCanvas.width=s.mW; maskCanvas.height=s.mH; colCanvas.width=s.cW; colCanvas.height=s.cH; }
  function resizePipeline(w,h){ [can.stain,can.ghost,can.final,proc,maskCanvas,colCanvas].forEach(c=>{ c.width=w; c.height=h; }); }
})();
</script>
</body>
</html>
